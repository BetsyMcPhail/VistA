KIDS Distribution saved on Oct 23, 2018@10:51:22
T2 -
**KIDS**:XU*8.0*10004^

**INSTALL NAME**
XU*8.0*10004
"BLD",10875,0)
XU*8.0*10004^KERNEL^0^3181023^y
"BLD",10875,1,0)
^^27^27^3181022^
"BLD",10875,1,1,0)
Authored on 10/22/2018 by Sam Habiel; licensed under Apache 2.0
"BLD",10875,1,2,0)
 
"BLD",10875,1,3,0)
Kernel fixes for Cache/GTM.
"BLD",10875,1,4,0)
 
"BLD",10875,1,5,0)
This is what's fixed:
"BLD",10875,1,6,0)
- ZSY: 
"BLD",10875,1,7,0)
-- Look for lsof in /usr/sbin as well.
"BLD",10875,1,8,0)
-- Don't assume U variable will be present in destination processes 
"BLD",10875,1,9,0)
-- DEFAULT region is not assumed to be named "DEFAULT"
"BLD",10875,1,10,0)
-- Preliminary implementation of DEBUG; not usable yet
"BLD",10875,1,11,0)
-- ZSY is much faster on Darwin now
"BLD",10875,1,12,0)
-- HALTALL bug fix--procs(i) array may not be in order; resulting in 
"BLD",10875,1,13,0)
missed processes
"BLD",10875,1,14,0)
-- $ZINT of $ZINT is us, not the one in ZU.
"BLD",10875,1,15,0)
 
"BLD",10875,1,16,0)
- ZOSVGUX: 
"BLD",10875,1,17,0)
-- $EC won't cut off long global references anymore due to bad parsing
"BLD",10875,1,18,0)
-- $T +0 use for routines in order not to missing them if they contain no 
"BLD",10875,1,19,0)
literals under GTM/YDB.
"BLD",10875,1,20,0)
-- DEFAULT region is not assumed to be named "DEFAULT"
"BLD",10875,1,21,0)
 
"BLD",10875,1,22,0)
- ZISHGUX: $T +0 use.
"BLD",10875,1,23,0)
-- $T +0 use for routines in order not to missing them if they contain no 
"BLD",10875,1,24,0)
literals under GTM/YDB.
"BLD",10875,1,25,0)
 
"BLD",10875,1,26,0)
- XPDUTL: $$PATCH^XPDUTL used to be limited up to a max patch number of 
"BLD",10875,1,27,0)
999.
"BLD",10875,4,0)
^9.64PA^^
"BLD",10875,6.3)
3
"BLD",10875,"INIT")
POST^XU810004
"BLD",10875,"KRN",0)
^9.67PA^779.2^20
"BLD",10875,"KRN",.4,0)
.4
"BLD",10875,"KRN",.401,0)
.401
"BLD",10875,"KRN",.402,0)
.402
"BLD",10875,"KRN",.403,0)
.403
"BLD",10875,"KRN",.5,0)
.5
"BLD",10875,"KRN",.84,0)
.84
"BLD",10875,"KRN",3.6,0)
3.6
"BLD",10875,"KRN",3.8,0)
3.8
"BLD",10875,"KRN",9.2,0)
9.2
"BLD",10875,"KRN",9.8,0)
9.8
"BLD",10875,"KRN",9.8,"NM",0)
^9.68A^5^5
"BLD",10875,"KRN",9.8,"NM",1,0)
ZSY^^0^B414695741
"BLD",10875,"KRN",9.8,"NM",2,0)
ZOSVGUX^^0^B48377511
"BLD",10875,"KRN",9.8,"NM",3,0)
ZISHGUX^^0^B87467441
"BLD",10875,"KRN",9.8,"NM",4,0)
XPDUTL^^0^B24584734
"BLD",10875,"KRN",9.8,"NM",5,0)
ZOSVGUT5^^0^B2329177
"BLD",10875,"KRN",9.8,"NM","B","XPDUTL",4)

"BLD",10875,"KRN",9.8,"NM","B","ZISHGUX",3)

"BLD",10875,"KRN",9.8,"NM","B","ZOSVGUT5",5)

"BLD",10875,"KRN",9.8,"NM","B","ZOSVGUX",2)

"BLD",10875,"KRN",9.8,"NM","B","ZSY",1)

"BLD",10875,"KRN",19,0)
19
"BLD",10875,"KRN",19.1,0)
19.1
"BLD",10875,"KRN",101,0)
101
"BLD",10875,"KRN",409.61,0)
409.61
"BLD",10875,"KRN",771,0)
771
"BLD",10875,"KRN",779.2,0)
779.2
"BLD",10875,"KRN",870,0)
870
"BLD",10875,"KRN",8989.51,0)
8989.51
"BLD",10875,"KRN",8989.52,0)
8989.52
"BLD",10875,"KRN",8994,0)
8994
"BLD",10875,"KRN","B",.4,.4)

"BLD",10875,"KRN","B",.401,.401)

"BLD",10875,"KRN","B",.402,.402)

"BLD",10875,"KRN","B",.403,.403)

"BLD",10875,"KRN","B",.5,.5)

"BLD",10875,"KRN","B",.84,.84)

"BLD",10875,"KRN","B",3.6,3.6)

"BLD",10875,"KRN","B",3.8,3.8)

"BLD",10875,"KRN","B",9.2,9.2)

"BLD",10875,"KRN","B",9.8,9.8)

"BLD",10875,"KRN","B",19,19)

"BLD",10875,"KRN","B",19.1,19.1)

"BLD",10875,"KRN","B",101,101)

"BLD",10875,"KRN","B",409.61,409.61)

"BLD",10875,"KRN","B",771,771)

"BLD",10875,"KRN","B",779.2,779.2)

"BLD",10875,"KRN","B",870,870)

"BLD",10875,"KRN","B",8989.51,8989.51)

"BLD",10875,"KRN","B",8989.52,8989.52)

"BLD",10875,"KRN","B",8994,8994)

"INIT")
POST^XU810004
"MBREQ")
0
"PKG",3,-1)
1^1
"PKG",3,0)
KERNEL^XU^SIGN-ON, SECURITY, MENU DRIVER, DEVICES, TASKMAN^
"PKG",3,20,0)
^9.402P^2^2
"PKG",3,20,1,0)
200^^XDRM200N
"PKG",3,20,1,1)

"PKG",3,20,2,0)
2^^RGDRM03
"PKG",3,20,2,1)

"PKG",3,20,"B",2,2)

"PKG",3,20,"B",200,1)

"PKG",3,22,0)
^9.49I^1^1
"PKG",3,22,1,0)
8.0^3051119^2960606^1
"PKG",3,22,1,"PAH",1,0)
10004^3181023
"PKG",3,22,1,"PAH",1,1,0)
^^27^27^3181023
"PKG",3,22,1,"PAH",1,1,1,0)
Authored on 10/22/2018 by Sam Habiel; licensed under Apache 2.0
"PKG",3,22,1,"PAH",1,1,2,0)
 
"PKG",3,22,1,"PAH",1,1,3,0)
Kernel fixes for Cache/GTM.
"PKG",3,22,1,"PAH",1,1,4,0)
 
"PKG",3,22,1,"PAH",1,1,5,0)
This is what's fixed:
"PKG",3,22,1,"PAH",1,1,6,0)
- ZSY: 
"PKG",3,22,1,"PAH",1,1,7,0)
-- Look for lsof in /usr/sbin as well.
"PKG",3,22,1,"PAH",1,1,8,0)
-- Don't assume U variable will be present in destination processes 
"PKG",3,22,1,"PAH",1,1,9,0)
-- DEFAULT region is not assumed to be named "DEFAULT"
"PKG",3,22,1,"PAH",1,1,10,0)
-- Preliminary implementation of DEBUG; not usable yet
"PKG",3,22,1,"PAH",1,1,11,0)
-- ZSY is much faster on Darwin now
"PKG",3,22,1,"PAH",1,1,12,0)
-- HALTALL bug fix--procs(i) array may not be in order; resulting in 
"PKG",3,22,1,"PAH",1,1,13,0)
missed processes
"PKG",3,22,1,"PAH",1,1,14,0)
-- $ZINT of $ZINT is us, not the one in ZU.
"PKG",3,22,1,"PAH",1,1,15,0)
 
"PKG",3,22,1,"PAH",1,1,16,0)
- ZOSVGUX: 
"PKG",3,22,1,"PAH",1,1,17,0)
-- $EC won't cut off long global references anymore due to bad parsing
"PKG",3,22,1,"PAH",1,1,18,0)
-- $T +0 use for routines in order not to missing them if they contain no 
"PKG",3,22,1,"PAH",1,1,19,0)
literals under GTM/YDB.
"PKG",3,22,1,"PAH",1,1,20,0)
-- DEFAULT region is not assumed to be named "DEFAULT"
"PKG",3,22,1,"PAH",1,1,21,0)
 
"PKG",3,22,1,"PAH",1,1,22,0)
- ZISHGUX: $T +0 use.
"PKG",3,22,1,"PAH",1,1,23,0)
-- $T +0 use for routines in order not to missing them if they contain no 
"PKG",3,22,1,"PAH",1,1,24,0)
literals under GTM/YDB.
"PKG",3,22,1,"PAH",1,1,25,0)
 
"PKG",3,22,1,"PAH",1,1,26,0)
- XPDUTL: $$PATCH^XPDUTL used to be limited up to a max patch number of 
"PKG",3,22,1,"PAH",1,1,27,0)
999.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
6
"RTN","XPDUTL")
0^4^B24584734
"RTN","XPDUTL",1,0)
XPDUTL ;SFISC/RSD - KIDS utilities ;Oct 22, 2018@10:13
"RTN","XPDUTL",2,0)
 ;;8.0;KERNEL;**21,28,39,81,100,108,137,181,275,491,511,559,10004**;Jul 10, 1995;Build 3
"RTN","XPDUTL",3,0)
 ; *10004* changes (c) Sam Habiel 2018
"RTN","XPDUTL",4,0)
 Q
"RTN","XPDUTL",5,0)
VERSION(X) ;Get current version from Package file, X=package name or
"RTN","XPDUTL",6,0)
 ;package namespace
"RTN","XPDUTL",7,0)
 N I
"RTN","XPDUTL",8,0)
 S I=$$LKPKG(X) Q:'I ""
"RTN","XPDUTL",9,0)
 Q $P($G(^DIC(9.4,+I,"VERSION")),"^")
"RTN","XPDUTL",10,0)
 ;
"RTN","XPDUTL",11,0)
VER(X) ;returns version number from Build file, X=build name
"RTN","XPDUTL",12,0)
 Q:X["*" $P(X,"*",2)
"RTN","XPDUTL",13,0)
 Q $P(X," ",$L(X," "))
"RTN","XPDUTL",14,0)
 ;
"RTN","XPDUTL",15,0)
STATUS(IEN) ;returns status from Install File, IEN=Install File IEN
"RTN","XPDUTL",16,0)
 I '$D(^XPD(9.7,IEN,0)) Q -1
"RTN","XPDUTL",17,0)
 Q $P(^XPD(9.7,IEN,0),U,9)
"RTN","XPDUTL",18,0)
 ;
"RTN","XPDUTL",19,0)
PKG(X) ;returns package name from Build file, X=build name
"RTN","XPDUTL",20,0)
 Q $S(X["*":$P(X,"*"),1:$P(X," ",1,$L(X," ")-1))
"RTN","XPDUTL",21,0)
 ;
"RTN","XPDUTL",22,0)
LAST(PKG,VER,REL) ;returns last patch applied for a Package, PATCH^DATE
"RTN","XPDUTL",23,0)
 ;PKG=package name, VER=version number, REL[optional]=1 if you want released patches only
"RTN","XPDUTL",24,0)
 ;Patch includes Seq # if Released
"RTN","XPDUTL",25,0)
 N PKGIEN,VERIEN,LATEST,PATCH,SUBIEN,Y
"RTN","XPDUTL",26,0)
 S PKGIEN=$$LKPKG($G(PKG)) Q:'PKGIEN -1
"RTN","XPDUTL",27,0)
 I $G(VER)="" S VER=$P($G(^DIC(9.4,PKGIEN,"VERSION")),"^") Q:'VER -1
"RTN","XPDUTL",28,0)
 S VERIEN=$O(^DIC(9.4,PKGIEN,22,"B",VER,"")) Q:'VERIEN -1
"RTN","XPDUTL",29,0)
 S LATEST=-1,PATCH=-1,SUBIEN=0
"RTN","XPDUTL",30,0)
 F  S SUBIEN=$O(^DIC(9.4,PKGIEN,22,VERIEN,"PAH",SUBIEN)) Q:SUBIEN'>0  S Y=$G(^(SUBIEN,0)) D:$P(Y,U,2)>LATEST
"RTN","XPDUTL",31,0)
 . I $G(REL),$P(Y,U)'["SEQ #" Q  ;released only, must contain SEQ
"RTN","XPDUTL",32,0)
 . S LATEST=$P(Y,U,2),PATCH=$P(Y,U)
"RTN","XPDUTL",33,0)
 Q PATCH_U_LATEST
"RTN","XPDUTL",34,0)
 ;
"RTN","XPDUTL",35,0)
PATCH(X) ;return 1 if patch X was installed, X=aaaa*nn.nn*nnn
"RTN","XPDUTL",36,0)
 Q:X'?1.4UN1"*"1.2N1"."1.2N.1(1"V",1"T").2N1"*"1.10N 0 ; *10004* Support up to 10 digits in the patch number
"RTN","XPDUTL",37,0)
 N %,I,J
"RTN","XPDUTL",38,0)
 S I=$$LKPKG($P(X,"*")) Q:'I 0
"RTN","XPDUTL",39,0)
 S J=$O(^DIC(9.4,I,22,"B",$P(X,"*",2),0)),X=$P(X,"*",3) Q:'J 0
"RTN","XPDUTL",40,0)
 ;check if patch is just a number
"RTN","XPDUTL",41,0)
 Q:$O(^DIC(9.4,I,22,J,"PAH","B",X,0)) 1
"RTN","XPDUTL",42,0)
 S %=$O(^DIC(9.4,I,22,J,"PAH","B",X_" SEQ"))
"RTN","XPDUTL",43,0)
 Q (X=+%)
"RTN","XPDUTL",44,0)
 ;
"RTN","XPDUTL",45,0)
INSTALDT(INSTALL,RESULT) ;returns number of installs, 0 if not installed or doesn't exist
"RTN","XPDUTL",46,0)
 ;input: INSTALL=required, Install name; RESULT=required, passed by reference
"RTN","XPDUTL",47,0)
 ;output: RESULT=number in RESULT array; RESULT(FM date/time)=TEST# ^ SEQ#
"RTN","XPDUTL",48,0)
 N CNT,DATE,IEN
"RTN","XPDUTL",49,0)
 K RESULT
"RTN","XPDUTL",50,0)
 S (IEN,CNT,RESULT)=0
"RTN","XPDUTL",51,0)
 I $G(INSTALL)="" Q 0
"RTN","XPDUTL",52,0)
 F  S IEN=$O(^XPD(9.7,"B",INSTALL,IEN)) Q:'IEN  D
"RTN","XPDUTL",53,0)
 .S DATE=$P($G(^XPD(9.7,IEN,1)),U,3) Q:'DATE
"RTN","XPDUTL",54,0)
 .S RESULT(DATE)=$G(^XPD(9.7,IEN,6)),CNT=CNT+1
"RTN","XPDUTL",55,0)
 S RESULT=CNT
"RTN","XPDUTL",56,0)
 Q CNT
"RTN","XPDUTL",57,0)
 ;
"RTN","XPDUTL",58,0)
NEWCP(XPD,XPDC,XPDP) ;create new check point, returns 0=error or ien
"RTN","XPDUTL",59,0)
 ;XPD=name, XPDC=call back, XPDP=parameters
"RTN","XPDUTL",60,0)
 Q:$G(XPD)="" 0
"RTN","XPDUTL",61,0)
 N %,XPDI,XPDJ,XPDF,XPDY
"RTN","XPDUTL",62,0)
 ;XPDCP="INI"=Pre-init, "INIT"=Post-init
"RTN","XPDUTL",63,0)
 S XPDI=$S(XPDCP="INIT":9.716,1:9.713)
"RTN","XPDUTL",64,0)
 S %=$$FIND1^DIC(XPDI,","_XPDA_",","X",XPD) Q:% %
"RTN","XPDUTL",65,0)
 S XPDF="+1,"_XPDA_",",XPDJ(XPDI,XPDF,.01)=XPD
"RTN","XPDUTL",66,0)
 S:$D(XPDC) XPDJ(XPDI,XPDF,2)=XPDC
"RTN","XPDUTL",67,0)
 S:$D(XPDP) XPDJ(XPDI,XPDF,3)=XPDP
"RTN","XPDUTL",68,0)
 D UPDATE^DIE("","XPDJ","XPDY")
"RTN","XPDUTL",69,0)
 Q $G(XPDY(1))
"RTN","XPDUTL",70,0)
 ;
"RTN","XPDUTL",71,0)
UPCP(XPD,XPDP) ;update check point, returns 0=error or ien
"RTN","XPDUTL",72,0)
 ;XPD=name, XPDP=parameters
"RTN","XPDUTL",73,0)
 N XPDI,XPDJ,XPDF,XPDY
"RTN","XPDUTL",74,0)
 ;XPDCP="INI"=Pre-init, "INIT"=Post-init
"RTN","XPDUTL",75,0)
 S XPDI=$S(XPDCP="INIT":9.716,1:9.713),XPDY=$$DICCP($G(XPD))
"RTN","XPDUTL",76,0)
 Q:'XPDY 0
"RTN","XPDUTL",77,0)
 S XPDF=XPDY_","_XPDA_","
"RTN","XPDUTL",78,0)
 S:$D(XPDP) XPDJ(XPDI,XPDF,3)=XPDP
"RTN","XPDUTL",79,0)
 D FILE^DIE("","XPDJ")
"RTN","XPDUTL",80,0)
 Q XPDY
"RTN","XPDUTL",81,0)
 ;
"RTN","XPDUTL",82,0)
COMCP(XPD) ;complete check point, returns 0=error or date/time
"RTN","XPDUTL",83,0)
 ;XPD=name
"RTN","XPDUTL",84,0)
 N XPDD,XPDI,XPDJ,XPDY
"RTN","XPDUTL",85,0)
 S XPDI=$S(XPDCP="INIT":9.716,1:9.713),XPDY=$$DICCP($G(XPD))
"RTN","XPDUTL",86,0)
 Q:'XPDY 0
"RTN","XPDUTL",87,0)
 S XPDD=$$NOW^XLFDT,XPDJ(XPDI,XPDY_","_XPDA_",",1)=XPDD
"RTN","XPDUTL",88,0)
 D FILE^DIE("","XPDJ")
"RTN","XPDUTL",89,0)
 Q XPDD
"RTN","XPDUTL",90,0)
 ;
"RTN","XPDUTL",91,0)
VERCP(XPD) ;verify check point, returns 1=completed, 0=not
"RTN","XPDUTL",92,0)
 ;-1=doesn't exist
"RTN","XPDUTL",93,0)
 ;XPD=name
"RTN","XPDUTL",94,0)
 N XPDI,XPDY
"RTN","XPDUTL",95,0)
 S XPDI=$S(XPDCP="INIT":9.716,1:9.713),XPDY=$$DICCP($G(XPD))
"RTN","XPDUTL",96,0)
 Q:'XPDY -1
"RTN","XPDUTL",97,0)
 Q ''$$GET1^DIQ(XPDI,XPDY_","_XPDA_",",1,"I")
"RTN","XPDUTL",98,0)
 ;
"RTN","XPDUTL",99,0)
PARCP(XPD,XPDF) ;returns parameters of check point
"RTN","XPDUTL",100,0)
 ;XPD=name, XPDF="PRE"
"RTN","XPDUTL",101,0)
 N XPDI,XPDY
"RTN","XPDUTL",102,0)
 I $G(XPDF)="PRE" N XPDCP S XPDCP="INI"
"RTN","XPDUTL",103,0)
 S XPDI=$S(XPDCP="INIT":9.716,1:9.713),XPDY=$$DICCP($G(XPD))
"RTN","XPDUTL",104,0)
 Q:'XPDY 0
"RTN","XPDUTL",105,0)
 Q $$GET1^DIQ(XPDI,XPDY_","_XPDA_",",3,"I")
"RTN","XPDUTL",106,0)
 ;
"RTN","XPDUTL",107,0)
CURCP(XPDF) ;returns current check point
"RTN","XPDUTL",108,0)
 ;XPDF flag - 0=externel, 1=internal
"RTN","XPDUTL",109,0)
 Q $S($G(XPDF):XPDCHECK,1:XPDCHECK(0))
"RTN","XPDUTL",110,0)
 ;
"RTN","XPDUTL",111,0)
WP(X) ;X=global ref
"RTN","XPDUTL",112,0)
 N %
"RTN","XPDUTL",113,0)
 Q:'$D(@X)
"RTN","XPDUTL",114,0)
 F %=1:1 Q:'$D(@X@(%))  W !,@X@(%)
"RTN","XPDUTL",115,0)
 Q:'$G(XPDA)  D WP^DIE(9.7,XPDA_",",20,"A",X)
"RTN","XPDUTL",116,0)
 Q
"RTN","XPDUTL",117,0)
MES(X) ;record message, X=message or an array passed by reference
"RTN","XPDUTL",118,0)
 N %
"RTN","XPDUTL",119,0)
 I $D(X)#2 S %=X K X S X(1)=%
"RTN","XPDUTL",120,0)
 ;write message
"RTN","XPDUTL",121,0)
 F %=1:1 Q:'$D(X(%))  W !,X(%)
"RTN","XPDUTL",122,0)
 Q:'$G(XPDA)  D WP^DIE(9.7,XPDA_",",20,"A","X")
"RTN","XPDUTL",123,0)
 Q
"RTN","XPDUTL",124,0)
BMES(X) ;add blank line before message
"RTN","XPDUTL",125,0)
 N %
"RTN","XPDUTL",126,0)
 I $D(X)#2 S %=X K X S X(1)=" ",X(2)=%
"RTN","XPDUTL",127,0)
 D MES(.X)
"RTN","XPDUTL",128,0)
 Q
"RTN","XPDUTL",129,0)
RTNUP(X,Y) ;update routine action, X=routine, Y=action
"RTN","XPDUTL",130,0)
 ;actions:  1=delete, 2=skip
"RTN","XPDUTL",131,0)
 N %
"RTN","XPDUTL",132,0)
 ;set action to Y
"RTN","XPDUTL",133,0)
 Q:'$G(Y)!'$D(^XTMP("XPDI",$G(XPDA),"RTN",X)) 0 S $P(^(X),U)=+Y
"RTN","XPDUTL",134,0)
 Q 1
"RTN","XPDUTL",135,0)
 ;get Build ien
"RTN","XPDUTL",136,0)
 S Y=$O(^XTMP("XPDI",XPDA,"BLD",0))
"RTN","XPDUTL",137,0)
 ;remove checksum when updating action, since action can only be
"RTN","XPDUTL",138,0)
 ;delete or skip, not sure if we want to do this
"RTN","XPDUTL",139,0)
 S:$P(%,U,2) $P(^XTMP("XPDI",XPDA,"BLD",Y,"KRN",9.8,"NM",$P(%,U,2),0),U,4)=""
"RTN","XPDUTL",140,0)
 Q 1
"RTN","XPDUTL",141,0)
 ;
"RTN","XPDUTL",142,0)
RTNLOG(X) ;Enter/Update routine in the Routine File
"RTN","XPDUTL",143,0)
 N Y,FDA,IEN
"RTN","XPDUTL",144,0)
 S Y=$O(^DIC(9.8,"B",X,0))
"RTN","XPDUTL",145,0)
 I Y'>0 S IEN="?+1,",FDA(9.8,IEN,1)="R"
"RTN","XPDUTL",146,0)
 I Y>0 S IEN=(+Y)_","
"RTN","XPDUTL",147,0)
 S FDA(9.8,IEN,.01)=X,FDA(9.8,IEN,7.4)=$$NOW^XLFDT
"RTN","XPDUTL",148,0)
 D UPDATE^DIE("","FDA","IEN")
"RTN","XPDUTL",149,0)
 Q
"RTN","XPDUTL",150,0)
 ;
"RTN","XPDUTL",151,0)
DICCP(X) ;lookup check point, returns ien or 0
"RTN","XPDUTL",152,0)
 Q:$G(X)="" 0
"RTN","XPDUTL",153,0)
 ;if they pass ien, fail if can't find
"RTN","XPDUTL",154,0)
 I X=+X S Y=X Q:'$D(^XPD(9.7,XPDA,XPDCP,Y,0)) 0
"RTN","XPDUTL",155,0)
 E  S Y=$$FIND1^DIC(XPDI,","_XPDA_",","X",X)
"RTN","XPDUTL",156,0)
 Q Y
"RTN","XPDUTL",157,0)
 ;
"RTN","XPDUTL",158,0)
PRODE(XPDN,XPD) ;enable/disable protocols, return 1 for success
"RTN","XPDUTL",159,0)
 ;XPDN=protocol name, XPD=1-enable, 0-disable
"RTN","XPDUTL",160,0)
 Q:$G(XPDN)="" 0
"RTN","XPDUTL",161,0)
 S XPD=+$G(XPD)
"RTN","XPDUTL",162,0)
 D KIDS^XQOO1($P(XPDSET,U,2),101,XPDN,.XPD)
"RTN","XPDUTL",163,0)
 Q $S(XPD<0:0,1:1)
"RTN","XPDUTL",164,0)
 ;
"RTN","XPDUTL",165,0)
OPTDE(XPDN,XPD) ;enable/disable options, return 1 for success
"RTN","XPDUTL",166,0)
 ;XPDN=protocol name, XPD=1-enable, 0-disable
"RTN","XPDUTL",167,0)
 Q:$G(XPDN)="" 0
"RTN","XPDUTL",168,0)
 S XPD=+$G(XPD)
"RTN","XPDUTL",169,0)
 D KIDS^XQOO1($P(XPDSET,U,2),19,XPDN,.XPD)
"RTN","XPDUTL",170,0)
 Q $S(XPD<0:0,1:1)
"RTN","XPDUTL",171,0)
 ;
"RTN","XPDUTL",172,0)
BUILD(XPDN,XPD) ;check if a build exists, return 1 for success
"RTN","XPDUTL",173,0)
 ;XPDN=build name, XPD=1-exist, 0-been removed
"RTN","XPDUTL",174,0)
 S XPD=$D(XPDT("NM",XPDN))
"RTN","XPDUTL",175,0)
 Q XPD
"RTN","XPDUTL",176,0)
 ;
"RTN","XPDUTL",177,0)
MAILGRP(X) ;Return mail group for package, X=package name or namespace
"RTN","XPDUTL",178,0)
 N XD,DIC,DR,DA,DIQ
"RTN","XPDUTL",179,0)
 S DA=$$LKPKG(X) Q:'DA ""
"RTN","XPDUTL",180,0)
 S DIC="^DIC(9.4,",DR=1938,DIQ="XD" D EN^DIQ1
"RTN","XPDUTL",181,0)
 Q $S($G(XD(9.4,DA,1938))="":"",1:"G."_XD(9.4,DA,1938))
"RTN","XPDUTL",182,0)
 ;
"RTN","XPDUTL",183,0)
LKPKG(X) ;Return Package ien,  X=package name or namespace
"RTN","XPDUTL",184,0)
 Q:$G(X)="" 0
"RTN","XPDUTL",185,0)
 N DA
"RTN","XPDUTL",186,0)
 I $L(X)<5 D  Q:DA +DA
"RTN","XPDUTL",187,0)
 .S DA=$O(^DIC(9.4,"C",X,0))
"RTN","XPDUTL",188,0)
 .S:'DA DA=$O(^DIC(9.4,"C2",X,0))
"RTN","XPDUTL",189,0)
 I $L(X)>3 S DA=$O(^DIC(9.4,"B",X,0))
"RTN","XPDUTL",190,0)
 Q +DA
"RTN","XU810004")
0^^B34349
"RTN","XU810004",1,0)
XU810004 ; OSE/SMH - Patch XU*8.0*10004 post install ;Oct 22, 2018@11:56
"RTN","XU810004",2,0)
 ;;8.0;KERNEL;**10004**;;Build 3
"RTN","XU810004",3,0)
 ;
"RTN","XU810004",4,0)
POST ;
"RTN","XU810004",5,0)
 D PATCH^ZTMGRSET(10004)
"RTN","XU810004",6,0)
 QUIT
"RTN","ZISHGUX")
0^3^B87467441
"RTN","ZISHGUX",1,0)
%ZISH ;ISF/AC,RWF,VEN/SMH - GT.M for Unix Host file Control ;Oct 23, 2018@09:52
"RTN","ZISHGUX",2,0)
 ;;8.0;KERNEL;**275,306,385,524,10001,10002,10004**;Jul 10, 1995;Build 3
"RTN","ZISHGUX",3,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZISHGUX",4,0)
 ; EPs OPEN,DEL1,CD,PWD,MAXREC,MKDIR,SIZE,WGETSYNC,DF,SEND,SENDTO1 
"RTN","ZISHGUX",5,0)
 ; --> authored by Sam Habiel 2016-2018.
"RTN","ZISHGUX",6,0)
 ; EPs MV,DEFDIR,FTG,READNXT,MGTF have bugs fixed by Sam Habiel 2016.
"RTN","ZISHGUX",7,0)
 ; 
"RTN","ZISHGUX",8,0)
 ;
"RTN","ZISHGUX",9,0)
OPEN(X1,X2,X3,X4,X5,X6) ;SR. Open file
"RTN","ZISHGUX",10,0)
 ;D OPEN^%ZISH([handlename],[directory],filename,[accessmode],[recsize])
"RTN","ZISHGUX",11,0)
 ;X1=handle name
"RTN","ZISHGUX",12,0)
 ;X2=directory, X3=filename, X4=access mode
"RTN","ZISHGUX",13,0)
 ;X5=new file max record size, X6=Subtype
"RTN","ZISHGUX",14,0)
 ; ZEXCEPT: IOM,IOSL,IOT,POP
"RTN","ZISHGUX",15,0)
 ;
"RTN","ZISHGUX",16,0)
 ; RPMS has a 3 parameter version (directory, file, access mode)
"RTN","ZISHGUX",17,0)
 ; If we only have 3 parameters, move them over from X1,X2,X3 ->
"RTN","ZISHGUX",18,0)
 ; X2,X3,X4
"RTN","ZISHGUX",19,0)
 ; RPMS's OPENI also quits with a value, unlike the VistA call.
"RTN","ZISHGUX",20,0)
 ; So I added $Q to check for that.
"RTN","ZISHGUX",21,0)
 I '$D(X4) S X4=X3,X3=X2,X2=X1 K X1
"RTN","ZISHGUX",22,0)
 ;
"RTN","ZISHGUX",23,0)
 N %,%1,%2,%IO,%I2,%P,%T,X,Y,$ETRAP
"RTN","ZISHGUX",24,0)
 S $ETRAP="G OPNERR^%ZISH"
"RTN","ZISHGUX",25,0)
 ; If X2 isn't supplied, get default directory; or resolve it if supplied
"RTN","ZISHGUX",26,0)
 S U="^",X2=$$DEFDIR($G(X2)),X4=$$UP^XLFSTR(X4)
"RTN","ZISHGUX",27,0)
 ;
"RTN","ZISHGUX",28,0)
 ; These are common sense
"RTN","ZISHGUX",29,0)
 S Y=$S(X4["A":"append",X4["R":"readonly",X4["W":"newversion",1:"readonly")
"RTN","ZISHGUX",30,0)
 ;
"RTN","ZISHGUX",31,0)
 ; Binary mode. ! and # have no effect.
"RTN","ZISHGUX",32,0)
 ; NB: Reads are in record size; writes pad out to record size
"RTN","ZISHGUX",33,0)
 N RECSIZE S RECSIZE=$G(X5,"512")
"RTN","ZISHGUX",34,0)
 I X4["B" S Y=Y_":fixed:nowrap:recordsize="_RECSIZE ; Binary Mode
"RTN","ZISHGUX",35,0)
 ;
"RTN","ZISHGUX",36,0)
 ; Streaming Mode (almost everybody wants this all of the time)
"RTN","ZISHGUX",37,0)
 I X4'["B",'$G(X5) S Y=Y_":nowrap:stream" ; Streaming Mode (default)
"RTN","ZISHGUX",38,0)
 ;
"RTN","ZISHGUX",39,0)
 ; Variable records mode. Records are TRUNCATED at a specific width,
"RTN","ZISHGUX",40,0)
 ; but, unlike fixed records, you can end them early with a !.
"RTN","ZISHGUX",41,0)
 I X4'["B",$G(X5)  S Y=Y_":variable:nowrap:recordsize="_+X5
"RTN","ZISHGUX",42,0)
 ;
"RTN","ZISHGUX",43,0)
 S:$E(Y)=":" $E(Y)=""
"RTN","ZISHGUX",44,0)
 S %IO=X2_X3,%I2="%IO:"_$S($L(Y):"("_Y_")",1:"")_":0"
"RTN","ZISHGUX",45,0)
 O @%I2 E  S POP=1 Q:$Q 1 Q
"RTN","ZISHGUX",46,0)
 ;
"RTN","ZISHGUX",47,0)
 S IO=%IO,IO(1,IO)="",IOT="HFS",IOM=80,IOSL=60,POP=0 D SUBTYPE^%ZIS3($G(X6))
"RTN","ZISHGUX",48,0)
 I $G(X1)]"" D SAVDEV^%ZISUTL(X1)
"RTN","ZISHGUX",49,0)
 Q:$Q 0 Q
"RTN","ZISHGUX",50,0)
OPNERR ;error on open
"RTN","ZISHGUX",51,0)
 ; ZEXCEPT: POP
"RTN","ZISHGUX",52,0)
 S POP=1,$ECODE=""
"RTN","ZISHGUX",53,0)
 ;U:$G(%P)]"" %P
"RTN","ZISHGUX",54,0)
 Q:$Q 1 Q
"RTN","ZISHGUX",55,0)
 ;
"RTN","ZISHGUX",56,0)
CLOSE(X) ;SR. Close HFS device not opened by %ZIS.
"RTN","ZISHGUX",57,0)
 ;X1=Handle name, IO=device
"RTN","ZISHGUX",58,0)
 I IO]"" C IO K IO(1,IO)
"RTN","ZISHGUX",59,0)
 I $G(X)]"" D RMDEV^%ZISUTL(X)
"RTN","ZISHGUX",60,0)
 I $D(IO("HOME"))!$D(^XUTL("XQ",$J,"IOS")) D HOME^%ZIS
"RTN","ZISHGUX",61,0)
 Q
"RTN","ZISHGUX",62,0)
DEL(%ZX1,%ZX2) ;ef,SR. Del fl(s)
"RTN","ZISHGUX",63,0)
 ;S Y=$$DEL^%ZISH("dir path",$NA(array))
"RTN","ZISHGUX",64,0)
 N %ZISH,%ZISHLGR,%ZX,X,%ZXDEL
"RTN","ZISHGUX",65,0)
 S %ZX1=$$DEFDIR($G(%ZX1)),%ZXDEL=1,%ZISH=""
"RTN","ZISHGUX",66,0)
 ;
"RTN","ZISHGUX",67,0)
 ; Error trap is for $D(@%ZX2)
"RTN","ZISHGUX",68,0)
 N $ET S $ET="S $EC="""" G DELVAL^%ZISH"
"RTN","ZISHGUX",69,0)
 I $D(@%ZX2)<10 G DELVAL  ; RPMS format
"RTN","ZISHGUX",70,0)
 E  G DELNAME ; VISTA format
"RTN","ZISHGUX",71,0)
 ;
"RTN","ZISHGUX",72,0)
DELVAL ; [Internal] Delete by Val
"RTN","ZISHGUX",73,0)
 ; RPMS allows you to pass %ZX2 by value -- so handle that here
"RTN","ZISHGUX",74,0)
 ; Also, in the RPMS format, 0 = success and 1 = failure
"RTN","ZISHGUX",75,0)
 ; (b/c that's the return value of the unix rm command)
"RTN","ZISHGUX",76,0)
 ;
"RTN","ZISHGUX",77,0)
 S $ET="S $EC="""" Q 1"
"RTN","ZISHGUX",78,0)
 S %ZXDEL=0
"RTN","ZISHGUX",79,0)
 S %ZISH=%ZX2
"RTN","ZISHGUX",80,0)
 S %ZX=$S(%ZISH[%ZX1:%ZISH,1:%ZX1_%ZISH)
"RTN","ZISHGUX",81,0)
 O %ZX:READONLY:0
"RTN","ZISHGUX",82,0)
 E  S %ZXDEL=1 Q  ; Can't open it.
"RTN","ZISHGUX",83,0)
 C %ZX:DELETE
"RTN","ZISHGUX",84,0)
 I $ZSEARCH(%ZX)]"" S %ZXDEL=1 ; Delete was not successful.
"RTN","ZISHGUX",85,0)
 Q %ZXDEL
"RTN","ZISHGUX",86,0)
 ; /end RPMS implementation
"RTN","ZISHGUX",87,0)
 ;
"RTN","ZISHGUX",88,0)
DELNAME ; [Internal] Delete by Name
"RTN","ZISHGUX",89,0)
 ; ZEXCEPT: %ZISH,%ZISHLGR,%ZX,X,%ZXDEL,%ZX1,%ZX2
"RTN","ZISHGUX",90,0)
 ; %ZX2 is a named array (VistA format)
"RTN","ZISHGUX",91,0)
 F  S %ZISH=$O(@%ZX2@(%ZISH)) Q:%ZISH=""  D
"RTN","ZISHGUX",92,0)
 . N $ETRAP S $ETRAP="D DELERR^%ZISH"
"RTN","ZISHGUX",93,0)
 . I %ZISH["*" S %ZXDEL=0 Q  ; Wild card not allowed.
"RTN","ZISHGUX",94,0)
 . S %ZX=$ZSEARCH(%ZX1_%ZISH)
"RTN","ZISHGUX",95,0)
 . Q:%ZX=""           ; File doesn't exist - not an error, just quit.
"RTN","ZISHGUX",96,0)
 . O %ZX:READONLY:0
"RTN","ZISHGUX",97,0)
 . E  S %ZXDEL=0 Q  ; Can't open it.
"RTN","ZISHGUX",98,0)
 . C %ZX:DELETE
"RTN","ZISHGUX",99,0)
 . I $ZSEARCH(%ZX)]"" S %ZXDEL=0 ; Delete was not successful.
"RTN","ZISHGUX",100,0)
 Q %ZXDEL
"RTN","ZISHGUX",101,0)
 ;
"RTN","ZISHGUX",102,0)
DELERR ;Trap any $ETRAP error, unwind and return.
"RTN","ZISHGUX",103,0)
 ; ZEXCEPT: %ZXDEL
"RTN","ZISHGUX",104,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","ZISHGUX",105,0)
 S %ZXDEL=0
"RTN","ZISHGUX",106,0)
 D UNWIND^%ZTER Q
"RTN","ZISHGUX",107,0)
 ;
"RTN","ZISHGUX",108,0)
DEL1(%ZX3) ;ef,SR. Delete one file
"RTN","ZISHGUX",109,0)
 N %ZI1,%ZI2
"RTN","ZISHGUX",110,0)
 D SPLIT(%ZX3,.%ZI1,.%ZI2) S %ZI2(%ZI2)=""
"RTN","ZISHGUX",111,0)
 Q $$DEL(%ZI1,$NA(%ZI2))
"RTN","ZISHGUX",112,0)
 ;
"RTN","ZISHGUX",113,0)
SPLIT(%I,%O1,%O2) ;[Public] Split to path,file
"RTN","ZISHGUX",114,0)
 N %D,D
"RTN","ZISHGUX",115,0)
 S %D="/",%O1="",%O2=""
"RTN","ZISHGUX",116,0)
 S D=$L(%I,%D),%O1=$P(%I,%D,1,D-1),%O2=$P(%I,%D,D)
"RTN","ZISHGUX",117,0)
 Q
"RTN","ZISHGUX",118,0)
LIST(%ZX1,%ZX2,%ZX3) ;ef,SR. Set local array holding fl names
"RTN","ZISHGUX",119,0)
 ;S Y=$$LIST^ZISH("/dir/","list_root","return_root")
"RTN","ZISHGUX",120,0)
 ;list_root can have XX("A*"), XX("test.com")...
"RTN","ZISHGUX",121,0)
 ;Both arrays passed as $NA values (closed roots).
"RTN","ZISHGUX",122,0)
 N %ZISH,%ZIX,%ZIY,POP,X
"RTN","ZISHGUX",123,0)
 N $ETRAP,$ESTACK
"RTN","ZISHGUX",124,0)
 S $ETRAP="G LSTX^%ZISH" ; for the next line
"RTN","ZISHGUX",125,0)
 S %ZX1=$$DEFDIR($G(%ZX1))
"RTN","ZISHGUX",126,0)
 ;
"RTN","ZISHGUX",127,0)
 ; RPMS allows %ZX2 to be passed by value and %ZX3 to be passed by reference
"RTN","ZISHGUX",128,0)
 ; Next line's error trap applies only to $D(@%ZX2)
"RTN","ZISHGUX",129,0)
 S $ETRAP="S $EC="""" Q $$LISTI()"
"RTN","ZISHGUX",130,0)
 I $D(@%ZX2)<10 Q $$LISTI()
"RTN","ZISHGUX",131,0)
 ;Get fls, Build listing in %ZISHDL1 with ls
"RTN","ZISHGUX",132,0)
 S $ETRAP="G LSTX^%ZISH"
"RTN","ZISHGUX",133,0)
 S %ZISH=""
"RTN","ZISHGUX",134,0)
 F  S %ZISH=$O(@%ZX2@(%ZISH)) Q:%ZISH=""  D
"RTN","ZISHGUX",135,0)
 . S %ZIX=$ZPARSE(%ZX1_%ZISH) Q:%ZIX=""
"RTN","ZISHGUX",136,0)
 . F  S %ZIY=$ZSEARCH(%ZIX) Q:%ZIY=""  S %ZIY=$ZPARSE(%ZIY,"NAME")_$ZPARSE(%ZIY,"TYPE"),@%ZX3@(%ZIY)=""
"RTN","ZISHGUX",137,0)
LSTX ;
"RTN","ZISHGUX",138,0)
 S $ECODE=""
"RTN","ZISHGUX",139,0)
 S $ETRAP="G LISTIX^%ZISH" ; This is in case $$DEFDIR fails but 2nd par is passed by reference (So @ on it will crash)
"RTN","ZISHGUX",140,0)
 Q ($Q(@%ZX3)]"")
"RTN","ZISHGUX",141,0)
 ;
"RTN","ZISHGUX",142,0)
LISTI() ; [Internal] RPMS implementation of directory lister
"RTN","ZISHGUX",143,0)
 ; %ZX1 by value; %ZX2 by value; %ZX3 by reference
"RTN","ZISHGUX",144,0)
 ; ZEXCEPT: %ZX1,%ZX2,%ZX3
"RTN","ZISHGUX",145,0)
 ; ZEXCEPT: %ZIX,%ZIY
"RTN","ZISHGUX",146,0)
 S $ETRAP="G LSTIX^%ZISH"
"RTN","ZISHGUX",147,0)
 I $G(%ZX1)']""!($G(%ZX2)']"") Q 0
"RTN","ZISHGUX",148,0)
 S %ZIX=$ZPARSE(%ZX1_%ZX2) Q:%ZIX="" 0
"RTN","ZISHGUX",149,0)
 N %ZISHN F %ZISHN=1:1 S %ZIY=$ZSEARCH(%ZIX) Q:%ZIY=""  D
"RTN","ZISHGUX",150,0)
 . S %ZIY=$ZPARSE(%ZIY,"NAME")_$ZPARSE(%ZIY,"TYPE")
"RTN","ZISHGUX",151,0)
 . S %ZX3(%ZISHN)=%ZIY
"RTN","ZISHGUX",152,0)
LISTIX ; [Internal] Error Trap target for LISTI; Fallthrough
"RTN","ZISHGUX",153,0)
 S $ECODE=""
"RTN","ZISHGUX",154,0)
 Q '$D(%ZX3)
"RTN","ZISHGUX",155,0)
 ;
"RTN","ZISHGUX",156,0)
MV(X1,X2,Y1,Y2) ;ef,SR. Rename a fl
"RTN","ZISHGUX",157,0)
 ;S Y=$$MV^ZISH("/dir/","fl","/dir/","fl")
"RTN","ZISHGUX",158,0)
 N %Z,%C
"RTN","ZISHGUX",159,0)
 S X1=$$DEFDIR($G(X1)),Y1=$$DEFDIR($G(Y1))
"RTN","ZISHGUX",160,0)
 S %C="mv "
"RTN","ZISHGUX",161,0)
 ;Pbv or qit
"RTN","ZISHGUX",162,0)
 I (X2="")!(Y2="") Q 0
"RTN","ZISHGUX",163,0)
 N % S %=$$RETURN^%ZOSV(%C_X1_X2_" "_Y1_Y2)
"RTN","ZISHGUX",164,0)
 S %Z=$ZSEARCH(Y1_Y2)
"RTN","ZISHGUX",165,0)
 Q $L(%Z)>0
"RTN","ZISHGUX",166,0)
 ;
"RTN","ZISHGUX",167,0)
CD(D) ; [Public] Change Directory
"RTN","ZISHGUX",168,0)
 S $ZD=D
"RTN","ZISHGUX",169,0)
 QUIT
"RTN","ZISHGUX",170,0)
 ;
"RTN","ZISHGUX",171,0)
PWD() ;ef,SR. Print working directory
"RTN","ZISHGUX",172,0)
 Q $ZDIRECTORY
"RTN","ZISHGUX",173,0)
 ;
"RTN","ZISHGUX",174,0)
DEFDIR(DF) ;ef. Default Dir and frmt
"RTN","ZISHGUX",175,0)
 S DF=$G(DF)
"RTN","ZISHGUX",176,0)
 S:DF="" DF=$P($G(^XTV(8989.3,1,"DEV")),"^",1)
"RTN","ZISHGUX",177,0)
 ;
"RTN","ZISHGUX",178,0)
 ; $ZPARSE is file specific; we need to tell it that we are looking for a DIRECTORY!
"RTN","ZISHGUX",179,0)
 ; Otherwise, we will get a false positive
"RTN","ZISHGUX",180,0)
 I $E(DF,$L(DF))'="/" S DF=DF_"/"
"RTN","ZISHGUX",181,0)
 ;
"RTN","ZISHGUX",182,0)
 S DF=$ZPARSE(DF)
"RTN","ZISHGUX",183,0)
 I DF="" S $EC=",U-INVALID-DIRECTORY,"
"RTN","ZISHGUX",184,0)
 ;
"RTN","ZISHGUX",185,0)
 Q DF
"RTN","ZISHGUX",186,0)
 ;
"RTN","ZISHGUX",187,0)
MKDIR(DIR) ; ef,SR. *10002* Make directory
"RTN","ZISHGUX",188,0)
 N % S %=$$RETURN^%ZOSV("mkdir -p "_DIR,1)
"RTN","ZISHGUX",189,0)
 Q %
"RTN","ZISHGUX",190,0)
 ;
"RTN","ZISHGUX",191,0)
SIZE(DIR,FILE) ; ef,SR. *10002* Get Size of a File
"RTN","ZISHGUX",192,0)
 I $ZV["Darwin" Q $$RETURN^%ZOSV("stat -f%z "_$$DEFDIR(DIR)_FILE)
"RTN","ZISHGUX",193,0)
 Q $$RETURN^%ZOSV("stat -c%s "_$$DEFDIR(DIR)_FILE)
"RTN","ZISHGUX",194,0)
 ;
"RTN","ZISHGUX",195,0)
WGETSYNC(server,remoteDir,localDir,filePatt,port,isTLS) ; ef,SR. *10002* Sync remote directory
"RTN","ZISHGUX",196,0)
 s port=$g(port,443)
"RTN","ZISHGUX",197,0)
 s isTLS=$g(isTLS,1)
"RTN","ZISHGUX",198,0)
 ;
"RTN","ZISHGUX",199,0)
 i $e(remoteDir)'="/" s remoteDir="/"_remoteDir
"RTN","ZISHGUX",200,0)
 ;
"RTN","ZISHGUX",201,0)
 n url s url="http"
"RTN","ZISHGUX",202,0)
 i isTLS s url=url_"s"
"RTN","ZISHGUX",203,0)
 s url=url_"://"_server_":"_port_remoteDir
"RTN","ZISHGUX",204,0)
 ;
"RTN","ZISHGUX",205,0)
 ; -r recursive
"RTN","ZISHGUX",206,0)
 ; -N Turn on time-stamping
"RTN","ZISHGUX",207,0)
 ; -nd Do not create directories
"RTN","ZISHGUX",208,0)
 ; -np Do not follow follow
"RTN","ZISHGUX",209,0)
 ; -A What to accept (file pattern)
"RTN","ZISHGUX",210,0)
 ; -P where to save
"RTN","ZISHGUX",211,0)
 ;
"RTN","ZISHGUX",212,0)
 ; Get compressed file from remote source
"RTN","ZISHGUX",213,0)
 n %cmd s %cmd="wget --header='Accept-Encoding: gzip' -rNndp -A '"_filePatt_"' '"_url_"' -P "_localDir
"RTN","ZISHGUX",214,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",215,0)
 i % quit %
"RTN","ZISHGUX",216,0)
 ;
"RTN","ZISHGUX",217,0)
 ; Rename them to .gz if they are really compressed
"RTN","ZISHGUX",218,0)
 n %cmd s %cmd="for f in `file "_localDir_"/* | grep gzip | cut -d':' -f1`; do mv $f $f.gz; done"
"RTN","ZISHGUX",219,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",220,0)
 i % quit %
"RTN","ZISHGUX",221,0)
 ;
"RTN","ZISHGUX",222,0)
 ; gunzip (but don't warn if there is nothing to do: -q)
"RTN","ZISHGUX",223,0)
 n %cmd s %cmd="gzip -dq "_localDir_"/*"
"RTN","ZISHGUX",224,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",225,0)
 i %=1 s %=0 ; BSD gzip (in OS X) will return 1 if there are no files to operate on. Error safe to ignore.
"RTN","ZISHGUX",226,0)
 i % quit %
"RTN","ZISHGUX",227,0)
 ;
"RTN","ZISHGUX",228,0)
 ; dos2unix
"RTN","ZISHGUX",229,0)
 n %cmd s %cmd="dos2unix "_localDir_"/"_filePatt
"RTN","ZISHGUX",230,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",231,0)
 i % quit %
"RTN","ZISHGUX",232,0)
 ;
"RTN","ZISHGUX",233,0)
 quit %
"RTN","ZISHGUX",234,0)
 ;
"RTN","ZISHGUX",235,0)
STATUS() ;ef,SR. Return EOF status
"RTN","ZISHGUX",236,0)
 U $I
"RTN","ZISHGUX",237,0)
 Q $ZEOF
"RTN","ZISHGUX",238,0)
 ;
"RTN","ZISHGUX",239,0)
EOF(X) ;Eof flag, Pass in $ZA
"RTN","ZISHGUX",240,0)
 Q X
"RTN","ZISHGUX",241,0)
 ;
"RTN","ZISHGUX",242,0)
MAKEREF(HF,IX,OVF) ;Internal call to rebuild global ref.
"RTN","ZISHGUX",243,0)
 ;Return %ZISHF,%ZISHO,%ZISHI,%ZISUB
"RTN","ZISHGUX",244,0)
 ; ZEXCEPT: %ZISHF,%ZISHO,%ZISHI,%ZISUB
"RTN","ZISHGUX",245,0)
 N I,F,MX
"RTN","ZISHGUX",246,0)
 S OVF=$G(OVF,"%ZISHOF")
"RTN","ZISHGUX",247,0)
 S %ZISHI=$QS(HF,IX),MX=$QL(HF) ;
"RTN","ZISHGUX",248,0)
 S F=$NA(@HF,IX-1) ;Get first part
"RTN","ZISHGUX",249,0)
 I IX=1 S %ZISHF=F_"(%ZISHI" ;Build root, IX=1
"RTN","ZISHGUX",250,0)
 I IX>1 S %ZISHF=$E(F,1,$L(F)-1)_",%ZISHI" ;Build root
"RTN","ZISHGUX",251,0)
 S %ZISHO=%ZISHF_","_OVF_",%OVFCNT)" ;Make overflow
"RTN","ZISHGUX",252,0)
 F I=IX+1:1:MX S %ZISHF=%ZISHF_",%ZISUB("_I_")",%ZISUB(I)=$QS(HF,I)
"RTN","ZISHGUX",253,0)
 S %ZISHF=%ZISHF_")"
"RTN","ZISHGUX",254,0)
 Q
"RTN","ZISHGUX",255,0)
FTG(%ZX1,%ZX2,%ZX3,%ZX4,%ZX5) ;ef,SR. Unload contents of host file into global
"RTN","ZISHGUX",256,0)
 ;p1=host file directory
"RTN","ZISHGUX",257,0)
 ;p2=host file name
"RTN","ZISHGUX",258,0)
 ;p3= $NAME REFERENCE INCLUDING STARTING SUBSCRIPT
"RTN","ZISHGUX",259,0)
 ;p4=INCREMENT SUBSCRIPT
"RTN","ZISHGUX",260,0)
 ;p5=Overflow subscript, defaults to "OVF"
"RTN","ZISHGUX",261,0)
 ; 
"RTN","ZISHGUX",262,0)
 N %ZA,%ZB,%ZC,%ZL,X,%OVFCNT,%CONT,%EXIT,%XX
"RTN","ZISHGUX",263,0)
 N I,%ZISH,%ZISH1,%ZISHI,%ZISHL,%ZISHLGR,%ZISHOF,%ZISHOX,%ZISHS,%ZX,%ZISHY,POP,%ZISUB,%ZISHF,%ZISHO
"RTN","ZISHGUX",264,0)
 S %ZX1=$$DEFDIR($G(%ZX1)),%ZISHOF=$G(%ZX5,"OVF")
"RTN","ZISHGUX",265,0)
 D MAKEREF(%ZX3,%ZX4,"%ZISHOF")
"RTN","ZISHGUX",266,0)
 D OPEN^%ZISH(,%ZX1,%ZX2,"R")
"RTN","ZISHGUX",267,0)
 I POP Q 0
"RTN","ZISHGUX",268,0)
 N $ETRAP,$ESTACK S %EXIT=0,$ETRAP="G FTGERR^%ZISH"
"RTN","ZISHGUX",269,0)
 N MAX S MAX=$$MAXREC(%ZISHF)
"RTN","ZISHGUX",270,0)
 U IO F  K %XX D READNXT(.%XX,MAX) Q:$$EOF(%ZA)  D
"RTN","ZISHGUX",271,0)
 . S @%ZISHF=%XX
"RTN","ZISHGUX",272,0)
 . I $D(%XX)>2 F %OVFCNT=1:1 Q:'$D(%XX(%OVFCNT))  S @%ZISHO=%XX(%OVFCNT)
"RTN","ZISHGUX",273,0)
 . S %ZISHI=%ZISHI+1
"RTN","ZISHGUX",274,0)
 . Q
"RTN","ZISHGUX",275,0)
 D CLOSE() ;Normal exit
"RTN","ZISHGUX",276,0)
 Q '%EXIT
"RTN","ZISHGUX",277,0)
 ;
"RTN","ZISHGUX",278,0)
FTGERR ; Error Trap for FTG
"RTN","ZISHGUX",279,0)
 Q:$ES>1
"RTN","ZISHGUX",280,0)
 S %ZA=1
"RTN","ZISHGUX",281,0)
 S %EXIT=1
"RTN","ZISHGUX",282,0)
 S $ECODE=""
"RTN","ZISHGUX",283,0)
 D CLOSE()
"RTN","ZISHGUX",284,0)
 Q:$Q '%EXIT Q
"RTN","ZISHGUX",285,0)
 ;
"RTN","ZISHGUX",286,0)
READNXT(REC,MAX) ;
"RTN","ZISHGUX",287,0)
 ; ZEXCEPT: %ZA
"RTN","ZISHGUX",288,0)
 N T,I,X,%
"RTN","ZISHGUX",289,0)
 U IO R X:0 S %ZA=$ZEOF,REC=$E(X,1,MAX-1)
"RTN","ZISHGUX",290,0)
 Q:$L(X)<MAX
"RTN","ZISHGUX",291,0)
 S %=MAX
"RTN","ZISHGUX",292,0)
 F I=1:1 Q:$L(X)<%  S REC(I)=$E(X,%,%+(MAX-2)),%=%+(MAX-1)
"RTN","ZISHGUX",293,0)
 Q
"RTN","ZISHGUX",294,0)
 ;
"RTN","ZISHGUX",295,0)
GTF(%ZX1,%ZX2,%ZX3,%ZX4) ;ef,SR. Load contents of global to host file.
"RTN","ZISHGUX",296,0)
 ;Previously name LOAD
"RTN","ZISHGUX",297,0)
 ;p1=$NAME of global reference
"RTN","ZISHGUX",298,0)
 ;p2=incrementing subscript
"RTN","ZISHGUX",299,0)
 ;p3=host file directory
"RTN","ZISHGUX",300,0)
 ;p4=host file name
"RTN","ZISHGUX",301,0)
 N %ZISHY,%ZISHLGR,%ZISHOX
"RTN","ZISHGUX",302,0)
 S %ZISHY=$$MGTF(%ZX1,%ZX2,$G(%ZX3),%ZX4,"W")
"RTN","ZISHGUX",303,0)
 Q %ZISHY
"RTN","ZISHGUX",304,0)
 ;
"RTN","ZISHGUX",305,0)
GATF(%ZX1,%ZX2,%ZX3,%ZX4) ;ef,SR. Append to host file.
"RTN","ZISHGUX",306,0)
 ;
"RTN","ZISHGUX",307,0)
 ;p1=$NAME of global reference
"RTN","ZISHGUX",308,0)
 ;p2=incrementing subscript
"RTN","ZISHGUX",309,0)
 ;p3=host file directory
"RTN","ZISHGUX",310,0)
 ;p4=host file name
"RTN","ZISHGUX",311,0)
 N %ZISHY
"RTN","ZISHGUX",312,0)
 S %ZISHY=$$MGTF(%ZX1,%ZX2,$G(%ZX3),%ZX4,"A")
"RTN","ZISHGUX",313,0)
 Q %ZISHY
"RTN","ZISHGUX",314,0)
 ;
"RTN","ZISHGUX",315,0)
MGTF(%ZX1,%ZX2,%ZX3,%ZX4,%ZX5) ;
"RTN","ZISHGUX",316,0)
 ;p1=$NAME of global reference
"RTN","ZISHGUX",317,0)
 ;p2=incrementing subscript
"RTN","ZISHGUX",318,0)
 ;p3=host file directory
"RTN","ZISHGUX",319,0)
 ;p4=host file name
"RTN","ZISHGUX",320,0)
 ; ZEXCEPT: POP
"RTN","ZISHGUX",321,0)
 N %ZISH,%ZISH1,%ZISHI,%ZISHL,%ZISHLGR,%ZISHS,%ZISHOX,IO,%ZX,Y,%ZISHF
"RTN","ZISHGUX",322,0)
 D MAKEREF(%ZX1,%ZX2)
"RTN","ZISHGUX",323,0)
 D OPEN^%ZISH(,%ZX3,%ZX4,%ZX5) ;Default dir set in open
"RTN","ZISHGUX",324,0)
 I POP Q 0
"RTN","ZISHGUX",325,0)
 U IO
"RTN","ZISHGUX",326,0)
 N $ETRAP S $ETRAP="S $EC="""" D CLOSE^%ZISH() Q 0"
"RTN","ZISHGUX",327,0)
 ;
"RTN","ZISHGUX",328,0)
 ; This algorithm takes 20ms for 200,4,5; 
"RTN","ZISHGUX",329,0)
 ; Prev algo was faster I think, but had a bug where it would stop early if we skipped a sub
"RTN","ZISHGUX",330,0)
 D  F  S %ZISHI=$O(@$NA(@%ZX1,%ZX2-1)@(%ZISHI)) Q:'%ZISHI  D
"RTN","ZISHGUX",331,0)
 . Q:'($D(@%ZISHF)#2)
"RTN","ZISHGUX",332,0)
 . W @%ZISHF,!
"RTN","ZISHGUX",333,0)
 D CLOSE() ;Normal Exit
"RTN","ZISHGUX",334,0)
 Q 1
"RTN","ZISHGUX",335,0)
 ;
"RTN","ZISHGUX",336,0)
MAXREC(GLO) ; [Public] Maximum Record Size for a Global
"RTN","ZISHGUX",337,0)
 ; Global passed by name
"RTN","ZISHGUX",338,0)
 ; ZEXCEPT: %UTZIMERR1
"RTN","ZISHGUX",339,0)
 N REGION S REGION=$VIEW("REGION",$NA(@GLO))
"RTN","ZISHGUX",340,0)
 I REGION="" S $EC=",U-ERROR,"
"RTN","ZISHGUX",341,0)
 I $D(%UTSIMERR1) S $EC=",U-SIM-ERR-1,"
"RTN","ZISHGUX",342,0)
 I $T(+0^%PEEKBYNAME)]"" Q $$^%PEEKBYNAME("gd_region.max_rec_size",REGION) ; +0 *10004*
"RTN","ZISHGUX",343,0)
 I $T(+0^%DSEWRAP)]"" N FDUMP D  Q FDUMP(REGION,"Maximum record size")     ; +0 *10004*
"RTN","ZISHGUX",344,0)
 . D DUMP^%DSEWRAP(REGION,.FDUMP,"fileheader","all")
"RTN","ZISHGUX",345,0)
 ; Failsafe
"RTN","ZISHGUX",346,0)
 Q 255
"RTN","ZISHGUX",347,0)
 ;
"RTN","ZISHGUX",348,0)
 ; -- RPMS ENTRY POINTS! --
"RTN","ZISHGUX",349,0)
 ;
"RTN","ZISHGUX",350,0)
DF(X) ;Directory format
"RTN","ZISHGUX",351,0)
 ; Pass X by ref - both input and output
"RTN","ZISHGUX",352,0)
 Q:X=""
"RTN","ZISHGUX",353,0)
 S X=$TR(X,"\","/")
"RTN","ZISHGUX",354,0)
 S:$E(X,$L(X))'="/" X=X_"/"
"RTN","ZISHGUX",355,0)
 Q
"RTN","ZISHGUX",356,0)
 ;
"RTN","ZISHGUX",357,0)
SEND(ZISH1,ZISH2,ZISH3,ZISHPARM) ;Send UNIX or Windows fl
"RTN","ZISHGUX",358,0)
 Q ""
"RTN","ZISHGUX",359,0)
 ;
"RTN","ZISHGUX",360,0)
SENDTO1(ZISH1,ZISH2)         ;use sendto1 script
"RTN","ZISHGUX",361,0)
 Q ""
"RTN","ZOSVGUT5")
0^5^B2329177
"RTN","ZOSVGUT5",1,0)
ZOSVGUT5 ; OSE/SMH - Unit Tests for GT.M VistA Port;Oct 23, 2018@10:29
"RTN","ZOSVGUT5",2,0)
 ;;8.0;KERNEL;**10004**;;Build 3
"RTN","ZOSVGUT5",3,0)
 ;
"RTN","ZOSVGUT5",4,0)
 D EN^%ut($t(+0),3)
"RTN","ZOSVGUT5",5,0)
 QUIT
"RTN","ZOSVGUT5",6,0)
 ;
"RTN","ZOSVGUT5",7,0)
STARTUP ;
"RTN","ZOSVGUT5",8,0)
 ; ZEXCEPT: %UTSIMERR1
"RTN","ZOSVGUT5",9,0)
 K %UTSIMERR1
"RTN","ZOSVGUT5",10,0)
 QUIT 
"RTN","ZOSVGUT5",11,0)
 ;
"RTN","ZOSVGUT5",12,0)
ZTMGRSET ; @TEST ZTMGRSET Rename GTM Routines
"RTN","ZOSVGUT5",13,0)
 D PATCH^ZTMGRSET(10004)
"RTN","ZOSVGUT5",14,0)
 D CHKTF^%ut($T(+2^%ZOSV)[10004)
"RTN","ZOSVGUT5",15,0)
 QUIT
"RTN","ZOSVGUT5",16,0)
 ;
"RTN","ZOSVGUT5",17,0)
EC ; @TEST $$EC^%ZOSV
"RTN","ZOSVGUT5",18,0)
 N EC
"RTN","ZOSVGUT5",19,0)
 N V S V=$name(^PS(222,333,444,555,666,777,888))
"RTN","ZOSVGUT5",20,0)
 D
"RTN","ZOSVGUT5",21,0)
 . N $ET,$ES S $ET="S EC=$$EC^%ZOSV,$EC="""" D UNWIND^ZU"
"RTN","ZOSVGUT5",22,0)
 . I @V
"RTN","ZOSVGUT5",23,0)
 D CHKTF^%ut($P(EC,",",4)["GVUNDEF")
"RTN","ZOSVGUT5",24,0)
 QUIT
"RTN","ZOSVGUT5",25,0)
 ;
"RTN","ZOSVGUT5",26,0)
ZSY ; @TEST RUN ZSY with lsof in sbin
"RTN","ZOSVGUT5",27,0)
 D ^ZSY
"RTN","ZOSVGUT5",28,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT5",29,0)
 QUIT
"RTN","ZOSVGUT5",30,0)
 ;
"RTN","ZOSVGUT5",31,0)
ACTJ ; @TEST Use of $T +0
"RTN","ZOSVGUT5",32,0)
 D CHKTF^%ut($$ACTJ^%ZOSV)
"RTN","ZOSVGUT5",33,0)
 QUIT
"RTN","ZOSVGUT5",34,0)
 ;
"RTN","ZOSVGUT5",35,0)
PATCH ; @TEST $$PATCH^XPDUTL, which prv accepted only 3 digits
"RTN","ZOSVGUT5",36,0)
 D CHKTF^%ut($$PATCH^XPDUTL("XU*8.0*10001"))
"RTN","ZOSVGUT5",37,0)
 QUIT
"RTN","ZOSVGUT5",38,0)
 ;
"RTN","ZOSVGUT5",39,0)
MAXREC ; @TEST $$MAXREC^%ZISH - $T +0
"RTN","ZOSVGUT5",40,0)
 ; ZEXCEPT: %UTSIMERR1
"RTN","ZOSVGUT5",41,0)
 D CHKTF^%ut($$MAXREC^%ZISH("^DD"))
"RTN","ZOSVGUT5",42,0)
 D CHKTF^%ut($$MAXREC^%ZISH($NA(^TMP("SAM",$J))))
"RTN","ZOSVGUT5",43,0)
 S %UTSIMERR1=1
"RTN","ZOSVGUT5",44,0)
 N % S %=$$FTG^%ZISH("/usr/include","stdlib.h",$NA(^TMP($J,1,0)),2,"VVV")
"RTN","ZOSVGUT5",45,0)
 D CHKEQ^%ut(%,0)
"RTN","ZOSVGUT5",46,0)
 K %UTSIMERR1
"RTN","ZOSVGUT5",47,0)
 N % S %=$$FTG^%ZISH("/usr/include","stdlib.h",$NA(^TMP($J,1,0)),2,"VVV")
"RTN","ZOSVGUT5",48,0)
 D CHKEQ^%ut(%,1)
"RTN","ZOSVGUT5",49,0)
 QUIT
"RTN","ZOSVGUX")
0^2^B48377511
"RTN","ZOSVGUX",1,0)
%ZOSV ;VEN/SMH,KRM/CJE,FIS/KSB - View commands & special functions. ;Oct 22, 2018@10:01
"RTN","ZOSVGUX",2,0)
 ;;8.0;KERNEL;**275,425,499,10001,10002,10004**;Jul 10, 1995;Build 3
"RTN","ZOSVGUX",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVGUX",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZOSVGUX",5,0)
 ; Almost the entire routine was rewritten by Sam Habiel, Christopher Edwards, KS Bhaskar
"RTN","ZOSVGUX",6,0)
 ;
"RTN","ZOSVGUX",7,0)
ACTJ() ; # active jobs
"RTN","ZOSVGUX",8,0)
 ; Next call active as of 6.3
"RTN","ZOSVGUX",9,0)
 I $T(+0^%PEEKBYNAME)]"" Q $$^%PEEKBYNAME("node_local.ref_cnt",$$DEFREG)
"RTN","ZOSVGUX",10,0)
 I ($G(^XUTL("XUSYS","CNT"))<1)!($G(^XUTL("XUSYS","CNT","SEC"))>($$SEC^XLFDT($H)+3600)) D
"RTN","ZOSVGUX",11,0)
 . I $$UP^XLFSTR($ZV)["LINUX" D
"RTN","ZOSVGUX",12,0)
 .. N I,IO,LINE
"RTN","ZOSVGUX",13,0)
 .. S IO=$IO
"RTN","ZOSVGUX",14,0)
 .. O "FTOK":(SHELL="/bin/sh":COMMAND="$gtm_dist/mupip ftok "_$$DEFFILE:READONLY)::"PIPE" U "FTOK"
"RTN","ZOSVGUX",15,0)
 .. F I=1:1:3 R LINE
"RTN","ZOSVGUX",16,0)
 .. O "IPCS":(SHELL="/bin/sh":COMMAND="ipcs -mi "_$TR($P($P(LINE,"::",3),"[",1)," ",""):READONLY)::"PIPE" U "IPCS"
"RTN","ZOSVGUX",17,0)
 .. F I=1:1 R LINE Q:$ZEO  I 1<$L(LINE,"nattch=") S ^XUTL("XUSYS","CNT")=+$P(LINE,"nattch=",2) Q
"RTN","ZOSVGUX",18,0)
 .. U IO C "FTOK" C "IPCS"
"RTN","ZOSVGUX",19,0)
 . ;
"RTN","ZOSVGUX",20,0)
 . I $$UP^XLFSTR($ZV)["DARWIN" D  ; OSEHRA/SMH - Should work on Linux too!
"RTN","ZOSVGUX",21,0)
 .. ; We previously used lsof against the default file, but that was TOOOOO SLOOOOW.
"RTN","ZOSVGUX",22,0)
 .. ; See https://apple.stackexchange.com/questions/81140/why-is-lsof-on-os-x-so-ridiculously-slow
"RTN","ZOSVGUX",23,0)
 .. ; Now we just do lsof against processes called mumps, and grep for the ones that have the default region open. xargs is used for trimming.
"RTN","ZOSVGUX",24,0)
 .. N %CMD S %CMD="pgrep mumps | xargs -n 1 -I{} lsof -p{} | grep "_$$DEFFILE_" | wc -l | xargs"
"RTN","ZOSVGUX",25,0)
 .. S ^XUTL("XUSYS","CNT")=$$RETURN^%ZOSV(%CMD)
"RTN","ZOSVGUX",26,0)
 . ;
"RTN","ZOSVGUX",27,0)
 . I $$UP^XLFSTR($ZV)["CYGWIN" D
"RTN","ZOSVGUX",28,0)
 .. S ^XUTL("XUSYS","CNT")=+$$RETURN^%ZOSV("ps -as | grep mumps | grep -v grep | wc -l")
"RTN","ZOSVGUX",29,0)
 . ;
"RTN","ZOSVGUX",30,0)
 . S ^XUTL("XUSYS","CNT","SEC")=$$SEC^XLFDT($H)
"RTN","ZOSVGUX",31,0)
 Q ^XUTL("XUSYS","CNT")
"RTN","ZOSVGUX",32,0)
 ;
"RTN","ZOSVGUX",33,0)
AVJ() ; # available jobs, Limit is in the OS.
"RTN","ZOSVGUX",34,0)
 N V,J
"RTN","ZOSVGUX",35,0)
 S V=^%ZOSF("VOL"),J=$O(^XTV(8989.3,1,4,"B",V,0)),J=$P($G(^XTV(8989.3,1,4,J,0),"^^1000"),"^",3)
"RTN","ZOSVGUX",36,0)
 Q J-$$ACTJ ;Use signon Max
"RTN","ZOSVGUX",37,0)
 ;
"RTN","ZOSVGUX",38,0)
DEFFILE() ; Default Region File Name ; *10004*
"RTN","ZOSVGUX",39,0)
 Q $V("GVFILE",$$DEFREG)
"RTN","ZOSVGUX",40,0)
 ;
"RTN","ZOSVGUX",41,0)
DEFREG() ; Default Region Name; *10004*
"RTN","ZOSVGUX",42,0)
 Q $VIEW("REGION","^DD")
"RTN","ZOSVGUX",43,0)
 ;
"RTN","ZOSVGUX",44,0)
RTNDIR() ; primary routine source directory
"RTN","ZOSVGUX",45,0)
 N DIRS
"RTN","ZOSVGUX",46,0)
 D PARSEZRO(.DIRS,$ZRO)
"RTN","ZOSVGUX",47,0)
 N I F I=1:1 Q:'$D(DIRS(I))  I DIRS(I)[".so" K DIRS(I)
"RTN","ZOSVGUX",48,0)
 I '$D(DIRS) S $EC=",U255,"
"RTN","ZOSVGUX",49,0)
 QUIT $$ZRO1ST(.DIRS)
"RTN","ZOSVGUX",50,0)
 ;
"RTN","ZOSVGUX",51,0)
PARSEZRO(DIRS,ZRO) ; Parse $zroutines properly into an array
"RTN","ZOSVGUX",52,0)
 ; Eat spaces
"RTN","ZOSVGUX",53,0)
 F  Q:($E(ZRO)'=" ")  S ZRO=$E(ZRO,2,1024) ; 1023 is the GT.M maximum
"RTN","ZOSVGUX",54,0)
 ;
"RTN","ZOSVGUX",55,0)
 N PIECE
"RTN","ZOSVGUX",56,0)
 N I
"RTN","ZOSVGUX",57,0)
 F I=1:1:$L(ZRO," ") S PIECE(I)=$P(ZRO," ",I)
"RTN","ZOSVGUX",58,0)
 N CNT S CNT=1
"RTN","ZOSVGUX",59,0)
 F I=0:0 S I=$O(PIECE(I)) Q:'I  D
"RTN","ZOSVGUX",60,0)
 . S DIRS(CNT)=$G(DIRS(CNT))_PIECE(I)
"RTN","ZOSVGUX",61,0)
 . I DIRS(CNT)["("&(DIRS(CNT)[")") S CNT=CNT+1 QUIT
"RTN","ZOSVGUX",62,0)
 . I DIRS(CNT)'["("&(DIRS(CNT)'[")") S CNT=CNT+1 QUIT
"RTN","ZOSVGUX",63,0)
 . S DIRS(CNT)=DIRS(CNT)_" " ; prep for next piece
"RTN","ZOSVGUX",64,0)
 QUIT
"RTN","ZOSVGUX",65,0)
 ;
"RTN","ZOSVGUX",66,0)
ZRO1ST(DIRS) ; $$ Get first usable routine directory
"RTN","ZOSVGUX",67,0)
 N OUT S OUT="" ; $$ Return; default empty
"RTN","ZOSVGUX",68,0)
 N I F I=0:0 S I=$O(DIRS(I)) Q:'I  D  Q:OUT]""  ; 1st directory
"RTN","ZOSVGUX",69,0)
 . N %1 S %1=DIRS(I)
"RTN","ZOSVGUX",70,0)
 . N SO S SO=$E(%1,$L(%1)-2,$L(%1))
"RTN","ZOSVGUX",71,0)
 . S SO=$$UP^XLFSTR(SO)
"RTN","ZOSVGUX",72,0)
 . I SO=".SO" QUIT
"RTN","ZOSVGUX",73,0)
 . ;
"RTN","ZOSVGUX",74,0)
 . ; Parse with (...)
"RTN","ZOSVGUX",75,0)
 . I %1["(" DO
"RTN","ZOSVGUX",76,0)
 . . S OUT=$P(%1,"(",2)
"RTN","ZOSVGUX",77,0)
 . . I OUT[" " S OUT=$P(OUT," ")
"RTN","ZOSVGUX",78,0)
 . . E  S OUT=$P(OUT,")")
"RTN","ZOSVGUX",79,0)
 . ; no parens
"RTN","ZOSVGUX",80,0)
 . E  S OUT=%1
"RTN","ZOSVGUX",81,0)
 ;
"RTN","ZOSVGUX",82,0)
 ; Add trailing slash
"RTN","ZOSVGUX",83,0)
 I OUT]"",$E(OUT,$L(OUT))'="/" S OUT=OUT_"/"
"RTN","ZOSVGUX",84,0)
 QUIT OUT
"RTN","ZOSVGUX",85,0)
 ;
"RTN","ZOSVGUX",86,0)
TEMP() ; Return path to temp directory
"RTN","ZOSVGUX",87,0)
 ;N %TEMP S %TEMP=$P($$RTNDIR," "),%TEMP=$P(%TEMP,"/",1,$L(%TEMP,"/")-2)_"/t/"
"RTN","ZOSVGUX",88,0)
 Q $G(^%ZOSF("TMP"),$P($G(^XTV(8989.3,1,"DEV"),"/tmp/"),U))
"RTN","ZOSVGUX",89,0)
 ;
"RTN","ZOSVGUX",90,0)
PASSALL ;
"RTN","ZOSVGUX",91,0)
 U $I:(NOESCAPE:NOTERMINATOR:PASTHRU) Q
"RTN","ZOSVGUX",92,0)
NOPASS ;
"RTN","ZOSVGUX",93,0)
 U $I:(ESCAPE:TERMINATOR="":NOPASTHRU) Q
"RTN","ZOSVGUX",94,0)
 ;
"RTN","ZOSVGUX",95,0)
GETPEER() ;Get the IP address of a connection peer
"RTN","ZOSVGUX",96,0)
 N PEER
"RTN","ZOSVGUX",97,0)
 S PEER=$P($ZTRNLNM("SSH_CLIENT")," ") S:PEER="" PEER=$ZTRNLNM("REMOTEHOST")
"RTN","ZOSVGUX",98,0)
 S PEER=$S($L(PEER):PEER,$L($G(IO("IP"))):IO("IP"),$L($G(IO("GTM-IP"))):IO("GTM-IP"),1:"")
"RTN","ZOSVGUX",99,0)
 I $G(^XTV(8989.3,1,"PEER"))[PEER S PEER="" ;p499
"RTN","ZOSVGUX",100,0)
 Q PEER
"RTN","ZOSVGUX",101,0)
 ;
"RTN","ZOSVGUX",102,0)
PRGMODE ;Drop into direct mode
"RTN","ZOSVGUX",103,0)
 N X,XUCI,XUSLNT
"RTN","ZOSVGUX",104,0)
 W ! S ZTPAC=$P($G(^VA(200,+DUZ,.1)),"^",5),XUVOL=^%ZOSF("VOL")
"RTN","ZOSVGUX",105,0)
 S X="" X ^%ZOSF("EOFF") R:ZTPAC]"" !,"PAC: ",X:60 D LC^XUS X ^%ZOSF("EON") I X'=ZTPAC W "??",$C(7) Q
"RTN","ZOSVGUX",106,0)
 N XMB,XMTEXT,XMY S XMB="XUPROGMODE",XMB(1)=DUZ,XMB(2)=$I D ^XMB:$L($T(+0^XMB)) D BYE^XUSCLEAN K ZTPAC,X,XMB
"RTN","ZOSVGUX",107,0)
 D UCI S XUCI=Y D PRGM^ZUA
"RTN","ZOSVGUX",108,0)
 I $D(%ut) QUIT
"RTN","ZOSVGUX",109,0)
 F  BREAK
"RTN","ZOSVGUX",110,0)
 HALT
"RTN","ZOSVGUX",111,0)
 ;
"RTN","ZOSVGUX",112,0)
PROGMODE() ; In Application mode
"RTN","ZOSVGUX",113,0)
 Q 1 ; This was used to control UCI switching, has no meaning in GT.M
"RTN","ZOSVGUX",114,0)
 ;
"RTN","ZOSVGUX",115,0)
UCI ;
"RTN","ZOSVGUX",116,0)
 S Y=^%ZOSF("PROD") Q
"RTN","ZOSVGUX",117,0)
 ;
"RTN","ZOSVGUX",118,0)
UCICHECK(X) ;
"RTN","ZOSVGUX",119,0)
 Q X
"RTN","ZOSVGUX",120,0)
 ;
"RTN","ZOSVGUX",121,0)
JOBPAR ; <=====
"RTN","ZOSVGUX",122,0)
 N CMD,COMM,IO
"RTN","ZOSVGUX",123,0)
 S IO=$IO,COMM="/proc/"_X_"/comm"
"RTN","ZOSVGUX",124,0)
 O COMM:(READONLY:EXCEPTION="S Y="""" Q") U COMM R CMD U IO C COMM
"RTN","ZOSVGUX",125,0)
 S Y=$S("mumps"=$G(CMD):^%ZOSF("PROD"),1:"")
"RTN","ZOSVGUX",126,0)
 Q
"RTN","ZOSVGUX",127,0)
 ;
"RTN","ZOSVGUX",128,0)
SHARELIC(TYPE) ;Used by Cache implementations
"RTN","ZOSVGUX",129,0)
 Q
"RTN","ZOSVGUX",130,0)
 ;
"RTN","ZOSVGUX",131,0)
PRIORITY ;
"RTN","ZOSVGUX",132,0)
 K Y ; VA has this disabled in general.
"RTN","ZOSVGUX",133,0)
 Q
"RTN","ZOSVGUX",134,0)
 ;
"RTN","ZOSVGUX",135,0)
PRIINQ() ;
"RTN","ZOSVGUX",136,0)
 Q 5 ; for now, we're always middle of the road
"RTN","ZOSVGUX",137,0)
 ;
"RTN","ZOSVGUX",138,0)
BAUD S X="UNKNOWN"
"RTN","ZOSVGUX",139,0)
 Q
"RTN","ZOSVGUX",140,0)
 ;
"RTN","ZOSVGUX",141,0)
LGR() ; Last global reference ($REFERENCE)
"RTN","ZOSVGUX",142,0)
 Q $R
"RTN","ZOSVGUX",143,0)
 ;
"RTN","ZOSVGUX",144,0)
EC() ; Error Code: returning $ZS in format more like $ZE from DSM
"RTN","ZOSVGUX",145,0)
 ; NB: Updated in patch *10004* to deal with multiple commas (as in global references)
"RTN","ZOSVGUX",146,0)
 N %ZE
"RTN","ZOSVGUX",147,0)
 I $ZS="" Q ""
"RTN","ZOSVGUX",148,0)
 S %ZE=$P($ZS,",",2)_","_$TR($P($ZS,",",4,999),",","'")_","_$P($ZS,",")_",-"_$P($ZS,",",3)
"RTN","ZOSVGUX",149,0)
 Q %ZE
"RTN","ZOSVGUX",150,0)
 ;
"RTN","ZOSVGUX",151,0)
DOLRO ;SAVE ENTIRE SYMBOL TABLE IN LOCATION SPECIFIED BY X
"RTN","ZOSVGUX",152,0)
 ; Old Algorithm
"RTN","ZOSVGUX",153,0)
 S Y="%" F  M @(X_"Y)="_Y) S Y=$O(@Y) Q:Y=""
"RTN","ZOSVGUX",154,0)
 QUIT
"RTN","ZOSVGUX",155,0)
 ;
"RTN","ZOSVGUX",156,0)
 ; New Algorithm; faster by 2-6ms
"RTN","ZOSVGUX",157,0)
 ;N %11111,Y
"RTN","ZOSVGUX",158,0)
 ;ZSHOW "V":%11111
"RTN","ZOSVGUX",159,0)
 ;N %00000 F %00000=0:0 S %00000=$O(%11111("V",%00000)) Q:'%00000  S Y=$P(%11111("V",%00000),"=") I Y'["(" M @(X_"Y)="_Y)
"RTN","ZOSVGUX",160,0)
 ;QUIT
"RTN","ZOSVGUX",161,0)
 ;
"RTN","ZOSVGUX",162,0)
ORDER ;SAVE PART OF SYMBOL TABLE IN LOCATION SPECIFIED BY X
"RTN","ZOSVGUX",163,0)
 N %
"RTN","ZOSVGUX",164,0)
 S (Y,%)=$P(Y,"*",1) ;I $D(@Y)=0 F  S Y=$O(@Y) Q:Y=""!(Y[Y1)
"RTN","ZOSVGUX",165,0)
 Q:Y=""
"RTN","ZOSVGUX",166,0)
 ;S %=$D(@Y) S:%#2 @(X_"Y)="_Y) I %>9 S %X=Y_"(",%Y=X_"Y," D %XY^%RCR
"RTN","ZOSVGUX",167,0)
 ;F  S Y=$O(@Y) Q:Y=""!(Y'[Y1)  S %=$D(@Y) S:%#2 @(X_"Y)="_Y) I %>9 S %X=Y_"(",%Y=X_"Y," D %XY^%RCR
"RTN","ZOSVGUX",168,0)
 F  M:$D(@Y) @(X_"Y)="_Y) S Y=$O(@Y) Q:Y=""!(Y'[%)
"RTN","ZOSVGUX",169,0)
 Q
"RTN","ZOSVGUX",170,0)
 ;
"RTN","ZOSVGUX",171,0)
PARSIZ ;
"RTN","ZOSVGUX",172,0)
 S X=3 Q
"RTN","ZOSVGUX",173,0)
 ;
"RTN","ZOSVGUX",174,0)
NOLOG ;
"RTN","ZOSVGUX",175,0)
 S Y=0 Q
"RTN","ZOSVGUX",176,0)
 ;
"RTN","ZOSVGUX",177,0)
GETENV ;Get environment Return Y='UCI^VOL^NODE^BOX LOOKUP'
"RTN","ZOSVGUX",178,0)
 N %HOST,%V S %V=^%ZOSF("PROD"),%HOST=$P($SYSTEM,",",2) ; Uses env variable gtm_sysid
"RTN","ZOSVGUX",179,0)
 S Y=$TR(%V,",","^")_"^"_%HOST_"^"_$P(%V,",",2)_":"_%HOST
"RTN","ZOSVGUX",180,0)
 Q
"RTN","ZOSVGUX",181,0)
 ;
"RTN","ZOSVGUX",182,0)
VERSION(X) ;return OS version, X=1 - return OS
"RTN","ZOSVGUX",183,0)
 Q $S($G(X):$P($ZV," ",3,99),1:$P($P($ZV," V",2)," "))
"RTN","ZOSVGUX",184,0)
 ;
"RTN","ZOSVGUX",185,0)
OS() ;
"RTN","ZOSVGUX",186,0)
 Q "UNIX"
"RTN","ZOSVGUX",187,0)
 ;
"RTN","ZOSVGUX",188,0)
SETNM(X) ;Set name, Trap dup's, Fall into SETENV
"RTN","ZOSVGUX",189,0)
 N $ETRAP S $ETRAP="S $ECODE="""" Q"
"RTN","ZOSVGUX",190,0)
SETENV ;Set environment X='PROCESS NAME^ '
"RTN","ZOSVGUX",191,0)
 S ^XUTL("XUSYS",$J,0)=$H,^("NM")=X ; workaround
"RTN","ZOSVGUX",192,0)
 Q
"RTN","ZOSVGUX",193,0)
 ;
"RTN","ZOSVGUX",194,0)
SID() ;System ID
"RTN","ZOSVGUX",195,0)
 N J1,T S T="~"
"RTN","ZOSVGUX",196,0)
 S J1(1)=$ZROUTINES,J1(1)=$P(J1(1)," ")
"RTN","ZOSVGUX",197,0)
 S J1(2)=$ZGBLDIR
"RTN","ZOSVGUX",198,0)
 Q "1~"_J1(1)_T_J1(2)
"RTN","ZOSVGUX",199,0)
 ;
"RTN","ZOSVGUX",200,0)
PRI() ;Check if a mixed OS enviroment.
"RTN","ZOSVGUX",201,0)
 ;Default return 1 unless we are on the secondary OS.
"RTN","ZOSVGUX",202,0)
 ;Only Cache on a VMS/Linux mix is supported now.
"RTN","ZOSVGUX",203,0)
 Q 1
"RTN","ZOSVGUX",204,0)
 ;
"RTN","ZOSVGUX",205,0)
T0 ; start RT clock
"RTN","ZOSVGUX",206,0)
 N V S V=$$VERSION(0)
"RTN","ZOSVGUX",207,0)
 I +V'<6.2 S %ZH0=$ZH QUIT
"RTN","ZOSVGUX",208,0)
 S %ZH0=$S(""'=$T(ZHOROLOG^%POSIX):$$ZHOROLOG^%POSIX,1:$H)
"RTN","ZOSVGUX",209,0)
 Q
"RTN","ZOSVGUX",210,0)
 ;
"RTN","ZOSVGUX",211,0)
T1 ; store RT datum w/ZHDIF
"RTN","ZOSVGUX",212,0)
 N V S V=$$VERSION(0)
"RTN","ZOSVGUX",213,0)
 I +V'<6.2 S %ZH1=$ZH QUIT
"RTN","ZOSVGUX",214,0)
 S %ZH1=$S(""'=$T(ZHOROLOG^%POSIX):$$ZHOROLOG^%POSIX,1:$H)
"RTN","ZOSVGUX",215,0)
 Q
"RTN","ZOSVGUX",216,0)
 ;
"RTN","ZOSVGUX",217,0)
ZHDIF ;Display dif of two $ZH's
"RTN","ZOSVGUX",218,0)
 N SC0 S SC0=$P(%ZH0,",",2)
"RTN","ZOSVGUX",219,0)
 N SC1 S SC1=$P(%ZH1,",",2)
"RTN","ZOSVGUX",220,0)
 N DC0 S DC0=$P(%ZH0,",")*86400
"RTN","ZOSVGUX",221,0)
 N DC1 S DC1=$P(%ZH1,",")*86400
"RTN","ZOSVGUX",222,0)
 N MCS0 S MCS0=$P(%ZH0,",",3)/1000000
"RTN","ZOSVGUX",223,0)
 N MCS1 S MCS1=$P(%ZH1,",",3)/1000000
"RTN","ZOSVGUX",224,0)
 ;
"RTN","ZOSVGUX",225,0)
 N T0 S T0=SC0+DC0+MCS0
"RTN","ZOSVGUX",226,0)
 N T1 S T1=SC1+DC1+MCS1
"RTN","ZOSVGUX",227,0)
 ;
"RTN","ZOSVGUX",228,0)
 S %ZH2=T1-T0
"RTN","ZOSVGUX",229,0)
 QUIT
"RTN","ZOSVGUX",230,0)
 ;
"RTN","ZOSVGUX",231,0)
 ;Code moved to %ZOSVKR, Comment out if needed.
"RTN","ZOSVGUX",232,0)
LOGRSRC(OPT,TYPE,STATUS) ;record resource usage in ^XTMP("KMPR"
"RTN","ZOSVGUX",233,0)
 Q:'$G(^%ZTSCH("LOGRSRC"))  ; quit if RUM not turned on.
"RTN","ZOSVGUX",234,0)
 ; call to RUM routine.
"RTN","ZOSVGUX",235,0)
 D RU^%ZOSVKR($G(OPT),$G(TYPE),$G(STATUS))
"RTN","ZOSVGUX",236,0)
 Q
"RTN","ZOSVGUX",237,0)
 ;
"RTN","ZOSVGUX",238,0)
SETTRM(X) ;Turn on specified terminators.
"RTN","ZOSVGUX",239,0)
 U $I:(TERMINATOR=X)
"RTN","ZOSVGUX",240,0)
 Q 1
"RTN","ZOSVGUX",241,0)
 ;
"RTN","ZOSVGUX",242,0)
DEVOK ;
"RTN","ZOSVGUX",243,0)
 ;use lsof (list open files)
"RTN","ZOSVGUX",244,0)
 ; given a device name in X
"RTN","ZOSVGUX",245,0)
 ;INPUT:  X=Device $I, X1=IOT -- X1 needed for resources
"RTN","ZOSVGUX",246,0)
 ;OUTPUT: Y=0 if available, Y=job # if owned
"RTN","ZOSVGUX",247,0)
 ; Y=-1 if device does not exists.
"RTN","ZOSVGUX",248,0)
 ; return Y=0 if not owned, Y=$J of owning job, Y=999 if dev cycling
"RTN","ZOSVGUX",249,0)
 ;
"RTN","ZOSVGUX",250,0)
 I $G(X1)="RES" G RESOK^%ZIS6
"RTN","ZOSVGUX",251,0)
 S Y=0
"RTN","ZOSVGUX",252,0)
 Q  ;Let ZIS deal with it.
"RTN","ZOSVGUX",253,0)
 ;
"RTN","ZOSVGUX",254,0)
DEVOPN ;List of Devices opened.  Linux only
"RTN","ZOSVGUX",255,0)
 ;Returns variable Y. Y=Devices owned separated by a comma
"RTN","ZOSVGUX",256,0)
 N %I,%X,%Y
"RTN","ZOSVGUX",257,0)
 ZSHOW "D":%Y
"RTN","ZOSVGUX",258,0)
 S %I=0,Y="",%X=""
"RTN","ZOSVGUX",259,0)
 F  S %I=$O(%Y("D",%I)) Q:'%I  I %Y("D",%I)'["CLOSED" S Y=Y_%X_$P(%Y("D",%I)," "),%X=","
"RTN","ZOSVGUX",260,0)
 Q
"RTN","ZOSVGUX",261,0)
 ;
"RTN","ZOSVGUX",262,0)
RETURN(%COMMAND,JUSTSTATUS) ; [Public] execute a shell command 
"RTN","ZOSVGUX",263,0)
 ; - return the last line; or just the status of the command.
"RTN","ZOSVGUX",264,0)
 ; %COMMAND is the string value of the Linux command
"RTN","ZOSVGUX",265,0)
 N IO,LINE,TMP
"RTN","ZOSVGUX",266,0)
 S IO=$IO
"RTN","ZOSVGUX",267,0)
 O "COMMAND":(SHELL="/bin/sh":COMMAND=%COMMAND:READONLY)::"PIPE" U "COMMAND"
"RTN","ZOSVGUX",268,0)
 F  R TMP:1 Q:$ZEO  S LINE=TMP
"RTN","ZOSVGUX",269,0)
 U IO C "COMMAND"
"RTN","ZOSVGUX",270,0)
 I $G(JUSTSTATUS) Q $ZCLOSE
"RTN","ZOSVGUX",271,0)
 Q $G(LINE)
"RTN","ZSY")
0^1^B414695741
"RTN","ZSY",1,0)
ZSY ;ISF/RWF,VEN/SMH - GT.M/VA system status display ;Oct 23, 2018@09:58
"RTN","ZSY",2,0)
 ;;8.0;KERNEL;**349,10001,10002,10004**;Jul 10, 1995;Build 3
"RTN","ZSY",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZSY",4,0)
 ; Original Routine of unknown provenance -- was in unreleased VA patch XU*8.0*349 and thus perhaps in the public domain.
"RTN","ZSY",5,0)
 ; Rewritten by KS Bhaskar and Sam Habiel 2005-2015
"RTN","ZSY",6,0)
 ; Sam: JOBEXAM, WORK, USHOW, UNIX, UNIXLSOF, INTRPT, INTRPTALL, HALTALL, ZJOBff
"RTN","ZSY",7,0)
 ; Bhaskar provided pipe implementations of various commands.
"RTN","ZSY",8,0)
 ;GT.M/VA %SY utility - status display
"RTN","ZSY",9,0)
 ;
"RTN","ZSY",10,0)
EN ; [Public] Main Entry Point
"RTN","ZSY",11,0)
 ;From the top just show by PID
"RTN","ZSY",12,0)
 N MODE
"RTN","ZSY",13,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",14,0)
 S MODE=0 D WORK(MODE)
"RTN","ZSY",15,0)
 Q
"RTN","ZSY",16,0)
 ;
"RTN","ZSY",17,0)
QUERY ; [Public] Alternate Entry Point
"RTN","ZSY",18,0)
 N MODE,X
"RTN","ZSY",19,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",20,0)
 S X=$$ASK W ! I X=-1 L -^XUTL("XUSYS","COMMAND") Q
"RTN","ZSY",21,0)
 S MODE=+X D WORK(MODE)
"RTN","ZSY",22,0)
 Q
"RTN","ZSY",23,0)
 ;
"RTN","ZSY",24,0)
TMMGR ; [Public] Show only taskman manager tasks
"RTN","ZSY",25,0)
 N MODE
"RTN","ZSY",26,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",27,0)
 N FILTER S FILTER("%ZTM")="",FILTER("%ZTM0")=""
"RTN","ZSY",28,0)
 S MODE=0 D WORK(MODE,.FILTER)
"RTN","ZSY",29,0)
 QUIT
"RTN","ZSY",30,0)
 ;
"RTN","ZSY",31,0)
TMSUB ; [Public] Show only taskman submanager tasks
"RTN","ZSY",32,0)
 N MODE
"RTN","ZSY",33,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",34,0)
 N FILTER S FILTER("%ZTMS1")=""
"RTN","ZSY",35,0)
 S MODE=0 D WORK(MODE,.FILTER)
"RTN","ZSY",36,0)
 QUIT
"RTN","ZSY",37,0)
 ;
"RTN","ZSY",38,0)
ASK() ;Ask sort item
"RTN","ZSY",39,0)
 ; ZEXCEPT: %utAnswer
"RTN","ZSY",40,0)
 I $D(%utAnswer) Q %utAnswer
"RTN","ZSY",41,0)
 N RES,X,GROUP
"RTN","ZSY",42,0)
 S RES=0,GROUP=2
"RTN","ZSY",43,0)
 W !,"1 pid",!,"2 cpu time"
"RTN","ZSY",44,0)
 F  R !,"1// ",X:600 S:X="" X=1 Q:X["^"  Q:(X>0)&(X<3)  W " not valid"
"RTN","ZSY",45,0)
 Q:X["^" -1
"RTN","ZSY",46,0)
 S X=X-1,RES=(X#GROUP)_"~"_(X\GROUP)
"RTN","ZSY",47,0)
 Q RES
"RTN","ZSY",48,0)
 ;
"RTN","ZSY",49,0)
 ;
"RTN","ZSY",50,0)
JOBEXAM(%ZPOS) ; [Public; Called by ^ZU]
"RTN","ZSY",51,0)
 ; Preserve old state for process
"RTN","ZSY",52,0)
 N OLDIO S OLDIO=$IO
"RTN","ZSY",53,0)
 N %reference S %reference=$REFERENCE
"RTN","ZSY",54,0)
 K ^XUTL("XUSYS",$J,"JE")
"RTN","ZSY",55,0)
 ;
"RTN","ZSY",56,0)
 ; Halt the Job if requested - no need to do other work
"RTN","ZSY",57,0)
 I $G(^XUTL("XUSYS",$J,"CMD"))="HALT" D H2^XUSCLEAN G HALT^ZU
"RTN","ZSY",58,0)
 ;
"RTN","ZSY",59,0)
 ;
"RTN","ZSY",60,0)
 ; Save these
"RTN","ZSY",61,0)
 S ^XUTL("XUSYS",$J,0)=$H
"RTN","ZSY",62,0)
 S ^XUTL("XUSYS",$J,"JE","INTERRUPT")=$G(%ZPOS)
"RTN","ZSY",63,0)
 S ^XUTL("XUSYS",$J,"JE","ZMODE")=$ZMODE ; SMH - INTERACTIVE or OTHER
"RTN","ZSY",64,0)
 I %ZPOS'["GTM$DMOD" S ^XUTL("XUSYS",$J,"JE","codeline")=$T(@%ZPOS)
"RTN","ZSY",65,0)
 I $G(DUZ) S ^XUTL("XUSYS",$J,"JE","UNAME")=$P($G(^VA(200,DUZ,0)),"^")
"RTN","ZSY",66,0)
 E           S ^XUTL("XUSYS",$J,"JE","UNAME")=$G(^XUTL("XUSYS",$J,"NM"))
"RTN","ZSY",67,0)
 ;
"RTN","ZSY",68,0)
 ;
"RTN","ZSY",69,0)
 ; Default System Status.
"RTN","ZSY",70,0)
 ; S -> Stack
"RTN","ZSY",71,0)
 ; D -> Devices
"RTN","ZSY",72,0)
 ; G -> Global Stats
"RTN","ZSY",73,0)
 ; L -> Locks
"RTN","ZSY",74,0)
 I '$D(^XUTL("XUSYS",$J,"CMD")) ZSHOW "SGDL":^XUTL("XUSYS",$J,"JE") ; Default case -- most of the time this is what happens.
"RTN","ZSY",75,0)
 ;
"RTN","ZSY",76,0)
 ; Examine the Job
"RTN","ZSY",77,0)
 ; ZSHOW "*" is "BDGILRV"
"RTN","ZSY",78,0)
 ; B is break points
"RTN","ZSY",79,0)
 ; D is Devices
"RTN","ZSY",80,0)
 ; G are global stats
"RTN","ZSY",81,0)
 ; I is ISVs
"RTN","ZSY",82,0)
 ; L is Locks
"RTN","ZSY",83,0)
 ; R is Routines with Hash (similar to S)
"RTN","ZSY",84,0)
 ; V is Variables
"RTN","ZSY",85,0)
 ; ZSHOW "*" does not include:
"RTN","ZSY",86,0)
 ; A -> Autorelink information
"RTN","ZSY",87,0)
 ; C -> External programs that are loaded (presumable with D &)
"RTN","ZSY",88,0)
 ; S -> Stack (use R instead)
"RTN","ZSY",89,0)
 I $G(^XUTL("XUSYS",$J,"CMD"))="EXAM"!($P($G(^("CMD")),"^")="DEBUG") ZSHOW "*":^XUTL("XUSYS",$J,"JE")
"RTN","ZSY",90,0)
 ;
"RTN","ZSY",91,0)
 ; ^XUTL("XUSYS",8563,"JE","G",0)="GLD:*,REG:*,SET:25610,KIL:593,GET:12284,...
"RTN","ZSY",92,0)
 ; Just grab the default region only. Decreases the stats as a side effect from this utility
"RTN","ZSY",93,0)
 N GLOSTAT
"RTN","ZSY",94,0)
 N I F I=0:0 S I=$O(^XUTL("XUSYS",$J,"JE","G",I)) Q:'I  I ^(I)[$ZGLD,^(I)[$$DEFREG() S GLOSTAT=^(I)
"RTN","ZSY",95,0)
 I GLOSTAT]"" N I F I=1:1:$L(GLOSTAT,",") D
"RTN","ZSY",96,0)
 . N EACHSTAT S EACHSTAT=$P(GLOSTAT,",",I)
"RTN","ZSY",97,0)
 . N SUB,OBJ S SUB=$P(EACHSTAT,":"),OBJ=$P(EACHSTAT,":",2)
"RTN","ZSY",98,0)
 . S ^XUTL("XUSYS",$J,"JE","GSTAT",SUB)=OBJ
"RTN","ZSY",99,0)
 ;
"RTN","ZSY",100,0)
 ; Capture IO statistics for this process
"RTN","ZSY",101,0)
 ; ZEXCEPT: READONLY,REWIND
"RTN","ZSY",102,0)
 I $ZV["Linux" D
"RTN","ZSY",103,0)
 . N F S F="/proc/"_$J_"/io"
"RTN","ZSY",104,0)
 . O F:(READONLY:REWIND):0 E  Q
"RTN","ZSY",105,0)
 . U F
"RTN","ZSY",106,0)
 . N DONE S DONE=0 ; $ZEOF doesn't seem to work (https://github.com/YottaDB/YottaDB/issues/120)
"RTN","ZSY",107,0)
 . N X F  R X:0 U F D  Q:DONE
"RTN","ZSY",108,0)
 .. I X["read_bytes"  S ^XUTL("XUSYS",$J,"JE","RBYTE")=$P(X,": ",2)
"RTN","ZSY",109,0)
 .. I X["write_bytes" S ^XUTL("XUSYS",$J,"JE","WBYTE")=$P(X,": ",2) S DONE=1
"RTN","ZSY",110,0)
 . U OLDIO C F
"RTN","ZSY",111,0)
 ;
"RTN","ZSY",112,0)
 ; Capture String Pool Stats: Full size - Freed Data
"RTN","ZSY",113,0)
 ; spstat 2nd piece is the actual size--but that fluctuates wildly
"RTN","ZSY",114,0)
 ; I use the full size allocated (defaults at 0.10 MB) - the size freed.
"RTN","ZSY",115,0)
 n spstat s spstat=$view("spsize")
"RTN","ZSY",116,0)
 ;
"RTN","ZSY",117,0)
 S ^XUTL("XUSYS",$J,"JE","SPOOL")=spstat
"RTN","ZSY",118,0)
 S ^XUTL("XUSYS",$J,"JE","HEAP_MEM")=$p(spstat,",",1)-$p(spstat,",",3)
"RTN","ZSY",119,0)
 ;
"RTN","ZSY",120,0)
 ; Done. We can tell others we are ready
"RTN","ZSY",121,0)
 SET ^XUTL("XUSYS",$J,"JE","COMPLETE")=1
"RTN","ZSY",122,0)
 ;
"RTN","ZSY",123,0)
 I $P($G(^XUTL("XUSYS",$J,"CMD")),"^")="DEBUG" DO
"RTN","ZSY",124,0)
 . ; Open local socket
"RTN","ZSY",125,0)
 . N TCPIO S TCPIO="SCK$LOCAL"
"RTN","ZSY",126,0)
 . O TCPIO:(CONNECT="/tmp/ydb-debug-socket:local":delim=$C(4):attach="client"):15:"socket"
"RTN","ZSY",127,0)
 . U TCPIO
"RTN","ZSY",128,0)
 . ; Connect to Debug Server
"RTN","ZSY",129,0)
 . W "$CONNECT",$C(4)
"RTN","ZSY",130,0)
 . S $ZSTEP="D ZSTEP^ZSY"
"RTN","ZSY",131,0)
 . ZSTEP INTO
"RTN","ZSY",132,0)
 ;
"RTN","ZSY",133,0)
 ; Restore old IO and $R
"RTN","ZSY",134,0)
 U OLDIO
"RTN","ZSY",135,0)
 I %reference
"RTN","ZSY",136,0)
 Q 1
"RTN","ZSY",137,0)
 ;
"RTN","ZSY",138,0)
ZSTEP ; Wait for commands
"RTN","ZSY",139,0)
 ; K ^ZZSAM
"RTN","ZSY",140,0)
 ; F  R X  S ^ZZSAM($I(^ZZSAM))=X D  I $E(X,1,2)="ZC" QUIT
"RTN","ZSY",141,0)
 ; . I $E(X,1,2)="ZC" QUIT
"RTN","ZSY",142,0)
 ; . N $ET,$ES S $ET="S $EC="""" W $C(4)"
"RTN","ZSY",143,0)
 ; . X X
"RTN","ZSY",144,0)
 ; . W $C(4)
"RTN","ZSY",145,0)
 ; . B
"RTN","ZSY",146,0)
 ; C TCPIO
"RTN","ZSY",147,0)
 ; QUIT
"RTN","ZSY",148,0)
 ;
"RTN","ZSY",149,0)
WORK(MODE,FILTER) ; [Private] Main driver, Will release lock
"RTN","ZSY",150,0)
 ; int MODE
"RTN","ZSY",151,0)
 ; FILTER ref
"RTN","ZSY",152,0)
 N USERS,GROUP,PROCID
"RTN","ZSY",153,0)
 N TNAME,I,SORT,TAB
"RTN","ZSY",154,0)
 N $ES,$ET
"RTN","ZSY",155,0)
 n %PS,RTN,%OS,DONE
"RTN","ZSY",156,0)
 ;
"RTN","ZSY",157,0)
 ;Save $ZINTERRUPT, set new one
"RTN","ZSY",158,0)
 N OLDINT
"RTN","ZSY",159,0)
 S OLDINT=$ZINTERRUPT,$ZINTERRUPT="I $$JOBEXAM($ZPOSITION) S DONE=1"
"RTN","ZSY",160,0)
 ;
"RTN","ZSY",161,0)
 ;Clear old data
"RTN","ZSY",162,0)
 S ^XUTL("XUSYS","COMMAND")="Status"
"RTN","ZSY",163,0)
 ;
"RTN","ZSY",164,0)
 S I=0 F  S I=$O(^XUTL("XUSYS",I)) Q:'I  K ^XUTL("XUSYS",I,"CMD"),^("JE")
"RTN","ZSY",165,0)
 ;
"RTN","ZSY",166,0)
 ; Counts; Turn on Ctrl-C.
"RTN","ZSY",167,0)
 ; ZEXCEPT: CTRAP,NOESCAPE,NOFILTER
"RTN","ZSY",168,0)
 N USERS S USERS=0
"RTN","ZSY",169,0)
 U $P:(CTRAP=$C(3):NOESCAPE:NOFILTER)
"RTN","ZSY",170,0)
 ;
"RTN","ZSY",171,0)
 ;Go get the data
"RTN","ZSY",172,0)
 D UNIX(MODE,.USERS,.SORT)
"RTN","ZSY",173,0)
 ;
"RTN","ZSY",174,0)
 ;Now show the results
"RTN","ZSY",175,0)
 I USERS D
"RTN","ZSY",176,0)
 . D HEADER(.TAB),USHOW(.TAB,.SORT,.FILTER)
"RTN","ZSY",177,0)
 . W !!,"Total ",USERS," user",$S(USERS>1:"s.",1:"."),!
"RTN","ZSY",178,0)
 . Q
"RTN","ZSY",179,0)
 E  W !,"No current GT.M users.",!
"RTN","ZSY",180,0)
 ;
"RTN","ZSY",181,0)
 ;
"RTN","ZSY",182,0)
EXIT ;
"RTN","ZSY",183,0)
 L -^XUTL("XUSYS","COMMAND") ;Release lock and let others in
"RTN","ZSY",184,0)
 I $L($G(OLDINT)) S $ZINTERRUPT=OLDINT
"RTN","ZSY",185,0)
 U $P:CTRAP=""
"RTN","ZSY",186,0)
 Q
"RTN","ZSY",187,0)
 ;
"RTN","ZSY",188,0)
ERR ;
"RTN","ZSY",189,0)
 U $P W !,$P($ZS,",",2,99),!
"RTN","ZSY",190,0)
 D EXIT
"RTN","ZSY",191,0)
 Q
"RTN","ZSY",192,0)
 ;
"RTN","ZSY",193,0)
LW ;Lock wait
"RTN","ZSY",194,0)
 W !,"Someone else is running the System status now."
"RTN","ZSY",195,0)
 Q
"RTN","ZSY",196,0)
 ;
"RTN","ZSY",197,0)
HEADER(TAB) ;Display Header
"RTN","ZSY",198,0)
 ; ZEXCEPT: AB
"RTN","ZSY",199,0)
 W #
"RTN","ZSY",200,0)
 S IOM=+$$AUTOMARG
"RTN","ZSY",201,0)
 W !,"GT.M System Status users on ",$$DATETIME($H)
"RTN","ZSY",202,0)
 W:IOM>80 " - (stats reflect accessing DEFAULT region ONLY except *)"
"RTN","ZSY",203,0)
 S TAB(0)=0,TAB(1)=6,TAB(2)=14,TAB(3)=18,TAB(4)=27,TAB(5)=46,TAB(6)=66
"RTN","ZSY",204,0)
 S TAB(7)=75,TAB(8)=85,TAB(9)=100,TAB(10)=110,TAB(11)=115,TAB(12)=123
"RTN","ZSY",205,0)
 S TAB(13)=130,TAB(14)=141,TAB(15)=150
"RTN","ZSY",206,0)
 U 0:FILTER="ESCAPE"
"RTN","ZSY",207,0)
 W !
"RTN","ZSY",208,0)
 D EACHHEADER("PID",TAB(0))
"RTN","ZSY",209,0)
 D EACHHEADER("PName",TAB(1))
"RTN","ZSY",210,0)
 D EACHHEADER("Device",TAB(2))
"RTN","ZSY",211,0)
 D EACHHEADER("Routine",TAB(4))
"RTN","ZSY",212,0)
 D EACHHEADER("Name",TAB(5))
"RTN","ZSY",213,0)
 D EACHHEADER("CPU Time",TAB(6))
"RTN","ZSY",214,0)
 I IOM>80 D
"RTN","ZSY",215,0)
 . D EACHHEADER("OP/READ",TAB(7))
"RTN","ZSY",216,0)
 . D EACHHEADER("NTR/NTW",TAB(8))
"RTN","ZSY",217,0)
 . D EACHHEADER("NR0123",TAB(9))
"RTN","ZSY",218,0)
 . D EACHHEADER("#L",TAB(10))
"RTN","ZSY",219,0)
 . D EACHHEADER("%LSUCC",TAB(11))
"RTN","ZSY",220,0)
 . D EACHHEADER("%CFAIL",TAB(12))
"RTN","ZSY",221,0)
 I IOM>130 D
"RTN","ZSY",222,0)
 . D EACHHEADER("R MB*",TAB(13))
"RTN","ZSY",223,0)
 . D EACHHEADER("W MB*",TAB(14))
"RTN","ZSY",224,0)
 . D EACHHEADER("SP MB*",TAB(15))
"RTN","ZSY",225,0)
 Q
"RTN","ZSY",226,0)
EACHHEADER(H,TAB) ; [Internal]
"RTN","ZSY",227,0)
 ; ZEXCEPT: AB
"RTN","ZSY",228,0)
 N BOLD S BOLD=$C(27,91,49,109)
"RTN","ZSY",229,0)
 N RESET S RESET=$C(27,91,109)
"RTN","ZSY",230,0)
 W ?TAB,BOLD,H,RESET
"RTN","ZSY",231,0)
 QUIT
"RTN","ZSY",232,0)
USHOW(TAB,SORT,FILTER) ;Display job info, sorted by pid
"RTN","ZSY",233,0)
 ; ZEXCEPT: AB
"RTN","ZSY",234,0)
 N SI,I
"RTN","ZSY",235,0)
 S SI=""
"RTN","ZSY",236,0)
 F  S SI=$ORDER(SORT(SI)) Q:SI=""  F I=1:1:SORT(SI) D
"RTN","ZSY",237,0)
 . N X,TNAME,PROCID,PROCNAME,CTIME,PS,PID,PLACE
"RTN","ZSY",238,0)
 . S X=SORT(SI,I)
"RTN","ZSY",239,0)
 . S PID=$P(X,"~",8)
"RTN","ZSY",240,0)
 . S PLACE=$G(^XUTL("XUSYS",PID,"JE","INTERRUPT"))
"RTN","ZSY",241,0)
 . ; Debug
"RTN","ZSY",242,0)
 . ; I $D(^XUTL("XUSYS",PID)) ZWRITE ^(PID,*)
"RTN","ZSY",243,0)
 . ; debug
"RTN","ZSY",244,0)
 . N RTNNAME S RTNNAME=$P(PLACE,"^",2)
"RTN","ZSY",245,0)
 . I $D(FILTER)=10 Q:$$FILTROUT(.FILTER,RTNNAME,PID)
"RTN","ZSY",246,0)
 . N DEV D DEV(.DEV,PID)
"RTN","ZSY",247,0)
 . S TNAME=$$DEVSEL(.DEV),PROCID=$P(X,"~",1) ; TNAME is Terminal Name, i.e. the device.
"RTN","ZSY",248,0)
 . S PROCNAME=$P(X,"~",5),CTIME=$P(X,"~",6)
"RTN","ZSY",249,0)
 . I $G(^XUTL("XUSYS",PID,"JE","ZMODE"))="OTHER" S TNAME="BG-"_TNAME
"RTN","ZSY",250,0)
 . N UNAME S UNAME=$G(^XUTL("XUSYS",PID,"JE","UNAME"))
"RTN","ZSY",251,0)
 . W !,PROCID,?TAB(1),PROCNAME,?TAB(2),TNAME,?TAB(4),PLACE,?TAB(5),UNAME,?TAB(6),$J(CTIME,6)
"RTN","ZSY",252,0)
 . I IOM>80 D
"RTN","ZSY",253,0)
 .. I '$D(^XUTL("XUSYS",PID,"JE","GSTAT","DRD")) W ?TAB(7),"PROCESS NOT RESPONDING" QUIT
"RTN","ZSY",254,0)
 .. N DRD,DTA,GET,ORD,ZPR,QRY
"RTN","ZSY",255,0)
 .. S DRD=^XUTL("XUSYS",PID,"JE","GSTAT","DRD"),DTA=^("DTA"),GET=^("GET"),ORD=^("ORD"),ZPR=^("ZPR"),QRY=^("QRY")
"RTN","ZSY",256,0)
 .. N opPerRead
"RTN","ZSY",257,0)
 .. i DRD=0 s opPerRead=0
"RTN","ZSY",258,0)
 .. e  S opPerRead=(DTA+GET+ORD+ZPR+QRY)/DRD
"RTN","ZSY",259,0)
 .. W ?TAB(7),$J(opPerRead,"",2)
"RTN","ZSY",260,0)
 .. N NTR,NTW S NTR=^XUTL("XUSYS",PID,"JE","GSTAT","NTR"),NTW=^("NTW") ; **NAKED**
"RTN","ZSY",261,0)
 .. I NTR>9999 S NTR=$J(NTR/1024,"",0)_"k",NTW=$J(NTW/1024,"",0)_"k"
"RTN","ZSY",262,0)
 .. W ?TAB(8),NTR,"/",NTW
"RTN","ZSY",263,0)
 .. W ?TAB(9),^XUTL("XUSYS",PID,"JE","GSTAT","NR0"),"/",^("NR1"),"/",^("NR2"),"/",^("NR3")
"RTN","ZSY",264,0)
 .. ; ^XUTL("XUSYS",14295,"JE","L",1)="LOCK ^XUTL(""XUSYS"",""COMMAND"") LEVEL=2"
"RTN","ZSY",265,0)
 .. N numLocks s numLocks=0
"RTN","ZSY",266,0)
 .. N I F I=0:0 S I=$O(^XUTL("XUSYS",PID,"JE","L",I)) Q:'I  N S S S=^(I) D  ; **NAKED**
"RTN","ZSY",267,0)
 ... N levelLocation S levelLocation=$find(S,"LEVEL=")
"RTN","ZSY",268,0)
 ... n level s level=+$E(S,levelLocation,999)
"RTN","ZSY",269,0)
 ... s numLocks=numLocks+level
"RTN","ZSY",270,0)
 .. W ?TAB(10),numLocks
"RTN","ZSY",271,0)
 .. N LKS,LKF S LKS=^XUTL("XUSYS",PID,"JE","GSTAT","LKS"),LKF=^("LKF")
"RTN","ZSY",272,0)
 .. N lockSuccess
"RTN","ZSY",273,0)
 .. I LKS+LKF'=0 S lockSuccess=LKS/(LKS+LKF)
"RTN","ZSY",274,0)
 .. e  s lockSuccess=0
"RTN","ZSY",275,0)
 .. W ?TAB(11)
"RTN","ZSY",276,0)
 .. i (LKS+LKF)<100 W LKS,"/",LKS+LKF
"RTN","ZSY",277,0)
 .. e  w $J(lockSuccess*100,"",2)_"%"
"RTN","ZSY",278,0)
 .. N CFT,CAT S CFT=$g(^XUTL("XUSYS",PID,"JE","GSTAT","CFT")),CAT=$g(^("CAT"))
"RTN","ZSY",279,0)
 .. N critAcqFailure
"RTN","ZSY",280,0)
 .. I CFT+CAT'=0 S critAcqFailure=CFT/(CFT+CAT)
"RTN","ZSY",281,0)
 .. e  s critAcqFailure=0
"RTN","ZSY",282,0)
 .. W ?TAB(12)
"RTN","ZSY",283,0)
 .. i (CFT+CAT)<100 W CFT,"/",CFT+CAT
"RTN","ZSY",284,0)
 .. e  w $J(critAcqFailure*100,"",2)_"%"
"RTN","ZSY",285,0)
 . I IOM>130 D
"RTN","ZSY",286,0)
 .. W ?TAB(13),$J($G(^XUTL("XUSYS",PID,"JE","RBYTE"))/(1024*1024),"",2)
"RTN","ZSY",287,0)
 .. W ?TAB(14),$J($G(^XUTL("XUSYS",PID,"JE","WBYTE"))/(1024*1024),"",2)
"RTN","ZSY",288,0)
 .. W ?TAB(15),$J($G(^XUTL("XUSYS",PID,"JE","HEAP_MEM"))/(1024*1024),"",2)
"RTN","ZSY",289,0)
 . ;
"RTN","ZSY",290,0)
 . ; Device print - Extract Info
"RTN","ZSY",291,0)
 . ; F DI=0:0 S DI=$O(DEV(DI)) Q:'DI  D
"RTN","ZSY",292,0)
 . ; W DEV(DI)
"RTN","ZSY",293,0)
 . ;I $O(DEV("")) D
"RTN","ZSY",294,0)
 .;. W !
"RTN","ZSY",295,0)
 .;. I IOM>130 W " " F DI=0:0 S DI=$O(DEV(DI)) Q:'DI
"RTN","ZSY",296,0)
 .;. E  W DEV(DI)  
"RTN","ZSY",297,0)
 .;.. W:$E(DEV(DI))=" " !
"RTN","ZSY",298,0)
 .;.. W ?TAB(1),DEV(DI)
"RTN","ZSY",299,0)
 Q
"RTN","ZSY",300,0)
 ;
"RTN","ZSY",301,0)
FILTROUT(FILTER,RTNNAME,PID) ; [Private] Should this item be filtered out?
"RTN","ZSY",302,0)
 I RTNNAME="" QUIT 1  ; yes, filter out processes that didn't respond
"RTN","ZSY",303,0)
 ; ^XUTL("XUSYS",24754,"JE","S",1)="JOBEXAM+22^ZSY"
"RTN","ZSY",304,0)
 ; ^XUTL("XUSYS",24754,"JE","S",2)="JOBEXAM+2^ZU"
"RTN","ZSY",305,0)
 ; ^XUTL("XUSYS",24754,"JE","S",3)="GETTASK+3^%ZTMS1    ($ZINTERRUPT) "
"RTN","ZSY",306,0)
 ; ^XUTL("XUSYS",24754,"JE","S",4)="SUBMGR+1^%ZTMS1"
"RTN","ZSY",307,0)
 n found s found=0
"RTN","ZSY",308,0)
 N I F I=1:1 Q:'$D(^XUTL("XUSYS",PID,"JE","S",I))  do  q:found
"RTN","ZSY",309,0)
 . i ^XUTL("XUSYS",PID,"JE","S",I)["Call-In" quit
"RTN","ZSY",310,0)
 . i ^XUTL("XUSYS",PID,"JE","S",I)["GTM$DMOD" quit
"RTN","ZSY",311,0)
 . n rtnName s rtnName=$p(^XUTL("XUSYS",PID,"JE","S",I),"^",2)
"RTN","ZSY",312,0)
 . i rtnName[" " s rtnName=$p(rtnName," ")
"RTN","ZSY",313,0)
 . n each s each=""
"RTN","ZSY",314,0)
 . f  s each=$o(FILTER(each)) q:each=""  do  q:found
"RTN","ZSY",315,0)
 .. i $d(FILTER(rtnName)) s found=1
"RTN","ZSY",316,0)
 ;
"RTN","ZSY",317,0)
 ; If we find it, we don't want to filter it out.
"RTN","ZSY",318,0)
 QUIT 'found
"RTN","ZSY",319,0)
 ;
"RTN","ZSY",320,0)
DEV(DEV,PID) ; [Private] Device Processing
"RTN","ZSY",321,0)
 ; Input: Global ^XUTL("XUSYS",PID,"JE","D"), PID
"RTN","ZSY",322,0)
 ; Output: .DEV
"RTN","ZSY",323,0)
 ; Device processing
"RTN","ZSY",324,0)
 ; First pass, normalize output into single lines
"RTN","ZSY",325,0)
 N DEVCNT,X
"RTN","ZSY",326,0)
 S DEVCNT=0
"RTN","ZSY",327,0)
 N DI F DI=1:1 Q:'$D(^XUTL("XUSYS",PID,"JE","D",DI))  S X=^(DI) D
"RTN","ZSY",328,0)
 . I X["CLOSED" QUIT  ; Don't print closed devices
"RTN","ZSY",329,0)
 . I PID=$J,$E(X,1,2)="ps" QUIT  ; Don't print our ps device
"RTN","ZSY",330,0)
 . I $E(X)'=" " S DEVCNT=DEVCNT+1,DEV(DEVCNT)=X
"RTN","ZSY",331,0)
 . E  S DEV(DEVCNT)=DEV(DEVCNT)_" "_$$TRIM(X)
"RTN","ZSY",332,0)
 ;
"RTN","ZSY",333,0)
 ; Second Pass, identify Devices
"RTN","ZSY",334,0)
 S DEVCNT="" F  S DEVCNT=$O(DEV(DEVCNT)) Q:DEVCNT=""  D
"RTN","ZSY",335,0)
 . S X=DEV(DEVCNT)
"RTN","ZSY",336,0)
 . N UPX S UPX=$ZCO(X,"U")
"RTN","ZSY",337,0)
 . I $E(X)=0 S DEV("4JOB")="0"
"RTN","ZSY",338,0)
 . I $P(X," ")["/dev/" S DEV("3TERM")=$P(X," ")
"RTN","ZSY",339,0)
 . I $P(X," ")["/",$P(X," ")'["/dev/" S DEV("1FILE")=$P(X," ")
"RTN","ZSY",340,0)
 . I UPX["SOCKET",UPX["SERVER" S DEV("2SOCK")=+$P(UPX,"PORT=",2)
"RTN","ZSY",341,0)
 QUIT
"RTN","ZSY",342,0)
 ;
"RTN","ZSY",343,0)
DEVSEL(DEV) ; [Private] Select Device to Print
"RTN","ZSY",344,0)
 N DEVTYP S DEVTYP=$O(DEV(" "))
"RTN","ZSY",345,0)
 Q:DEVTYP="" ""
"RTN","ZSY",346,0)
 I DEVTYP="4JOB" Q "0"
"RTN","ZSY",347,0)
 I DEVTYP="2SOCK" Q "S"_DEV(DEVTYP)
"RTN","ZSY",348,0)
 I DEVTYP="3TERM" Q DEV(DEVTYP)
"RTN","ZSY",349,0)
 I DEVTYP="1FILE" Q DEV(DEVTYP)
"RTN","ZSY",350,0)
 Q "ERROR"
"RTN","ZSY",351,0)
 ;
"RTN","ZSY",352,0)
TRIM(STR) ; [Private] Trim spaces
"RTN","ZSY",353,0)
 Q $$FUNC^%TRIM(STR)
"RTN","ZSY",354,0)
 ;
"RTN","ZSY",355,0)
DATETIME(HOROLOG) ;
"RTN","ZSY",356,0)
 Q $ZDATE(HOROLOG,"DD-MON-YY 24:60:SS")
"RTN","ZSY",357,0)
 ;
"RTN","ZSY",358,0)
UNIX(MODE,USERS,SORT) ;PUG/TOAD,FIS/KSB,VEN/SMH - Kernel System Status Report for GT.M
"RTN","ZSY",359,0)
 N %I,U,$ET,$ES
"RTN","ZSY",360,0)
 S $ET="D UERR^ZSY"
"RTN","ZSY",361,0)
 S %I=$I,U="^"
"RTN","ZSY",362,0)
 n procs
"RTN","ZSY",363,0)
 D INTRPTALL(.procs)
"RTN","ZSY",364,0)
 H .205 ; 200ms for TCP Read processes; 5ms b/c I am nice.
"RTN","ZSY",365,0)
 ; H .005 ; 200ms for TCP Read processes; 5ms b/c I am nice.
"RTN","ZSY",366,0)
 n procgrps
"RTN","ZSY",367,0)
 n done s done=0
"RTN","ZSY",368,0)
 n j s j=1
"RTN","ZSY",369,0)
 n i s i=0 f  s i=$o(procs(i)) q:'i  d
"RTN","ZSY",370,0)
 . s procgrps(j)=$g(procgrps(j))_procs(i)_" "
"RTN","ZSY",371,0)
 . i $l(procgrps(j))>220 s j=j+1 ; Max GT.M pipe len is 255
"RTN","ZSY",372,0)
 f j=1:1 q:'$d(procgrps(j))  d
"RTN","ZSY",373,0)
 . N %LINE,%TEXT,CMD
"RTN","ZSY",374,0)
 . I $ZV["Linux" S CMD="ps o pid,tty,stat,time,cmd -p"_procgrps(j)
"RTN","ZSY",375,0)
 . I $ZV["Darwin" S CMD="ps o pid,tty,stat,time,args -p"_procgrps(j)
"RTN","ZSY",376,0)
 . I $ZV["CYGWIN" S CMD="for p in "_procgrps(j)_"; do ps -p $p; done | awk '{print $1"" ""$5"" n/a ""$7"" ""$8"" n/a ""}'"
"RTN","ZSY",377,0)
 . ; ZEXCEPT: COMMAND,READONLY,SHELL
"RTN","ZSY",378,0)
 . O "ps":(SHELL="/bin/sh":COMMAND=CMD:READONLY)::"PIPE" U "ps"
"RTN","ZSY",379,0)
 . F  R %TEXT Q:$ZEO  D
"RTN","ZSY",380,0)
 .. S %LINE=$$VPE(%TEXT," ",U) ; parse each line of the ps output
"RTN","ZSY",381,0)
 .. Q:$P(%LINE,U)="PID"  ; header line
"RTN","ZSY",382,0)
 .. D JOBSET(%LINE,MODE,.USERS,.SORT)
"RTN","ZSY",383,0)
 . U %I C "ps"
"RTN","ZSY",384,0)
 Q
"RTN","ZSY",385,0)
 ;
"RTN","ZSY",386,0)
UERR ;Linux Error
"RTN","ZSY",387,0)
 N ZE S ZE=$ZS,$EC="" U $P
"RTN","ZSY",388,0)
 ZSHOW "*"
"RTN","ZSY",389,0)
 Q  ;halt
"RTN","ZSY",390,0)
 ;
"RTN","ZSY",391,0)
JOBSET(%LINE,MODE,USERS,SORT) ;Get data from a Linux job
"RTN","ZSY",392,0)
 N %J
"RTN","ZSY",393,0)
 N UNAME,PS,TNAME,CTIME
"RTN","ZSY",394,0)
 S (UNAME,PS,TNAME,CTIME)=""
"RTN","ZSY",395,0)
 N %J,PID,PROCID S (%J,PID,PROCID)=$P(%LINE,U)
"RTN","ZSY",396,0)
 S TNAME=$P(%LINE,U,2) S:TNAME="?" TNAME="" ; TTY, ? if none
"RTN","ZSY",397,0)
 S PS=$P(%LINE,U,3) ; process STATE
"RTN","ZSY",398,0)
 S CTIME=$P(%LINE,U,4) ;cpu time
"RTN","ZSY",399,0)
 N PROCNAME S PROCNAME=$P(%LINE,U,5) ; process name
"RTN","ZSY",400,0)
 I PROCNAME["/" S PROCNAME=$P(PROCNAME,"/",$L(PROCNAME,"/")) ; get actual image name if path
"RTN","ZSY",401,0)
 I $D(^XUTL("XUSYS",%J)) S UNAME=$G(^XUTL("XUSYS",%J,"NM"))
"RTN","ZSY",402,0)
 E  S UNAME="unknown"
"RTN","ZSY",403,0)
 N SI S SI=$S(MODE=0:PID,MODE=1:CTIME,1:PID)
"RTN","ZSY",404,0)
 N I S I=$GET(SORT(SI))+1
"RTN","ZSY",405,0)
 S SORT(SI)=I
"RTN","ZSY",406,0)
 S SORT(SI,I)=PROCID_"~"_UNAME_"~"_PS_"~"_TNAME_"~"_PROCNAME_"~"_CTIME_"~"_""_"~"_PID
"RTN","ZSY",407,0)
 S USERS=USERS+1
"RTN","ZSY",408,0)
 Q
"RTN","ZSY",409,0)
 ;
"RTN","ZSY",410,0)
VPE(%OLDSTR,%OLDDEL,%NEWDEL) ; $PIECE extract based on variable length delimiter
"RTN","ZSY",411,0)
 N %LEN,%PIECE,%NEWSTR
"RTN","ZSY",412,0)
 S %OLDDEL=$G(%OLDDEL) I %OLDDEL="" S %OLDDEL=" "
"RTN","ZSY",413,0)
 S %LEN=$L(%OLDDEL)
"RTN","ZSY",414,0)
 ; each %OLDDEL-sized chunk of %OLDSTR that might be delimiter
"RTN","ZSY",415,0)
 S %NEWDEL=$G(%NEWDEL) I %NEWDEL="" S %NEWDEL="^"
"RTN","ZSY",416,0)
 ; each piece of the old string
"RTN","ZSY",417,0)
 S %NEWSTR="" ; new reformatted string to retun
"RTN","ZSY",418,0)
 F  Q:%OLDSTR=""  D
"RTN","ZSY",419,0)
 . S %PIECE=$P(%OLDSTR,%OLDDEL)
"RTN","ZSY",420,0)
 . S $P(%OLDSTR,%OLDDEL)=""
"RTN","ZSY",421,0)
 . S %NEWSTR=%NEWSTR_$S(%NEWSTR="":"",1:%NEWDEL)_%PIECE
"RTN","ZSY",422,0)
 . F  Q:%OLDDEL'=$E(%OLDSTR,1,%LEN)  S $E(%OLDSTR,1,%LEN)=""
"RTN","ZSY",423,0)
 Q %NEWSTR
"RTN","ZSY",424,0)
 ;
"RTN","ZSY",425,0)
 ; Sam's entry points
"RTN","ZSY",426,0)
UNIXLSOF(procs) ; [Public] - Get all processes accessing THIS database (only!)
"RTN","ZSY",427,0)
 ; (return) .procs(n)=unix process number
"RTN","ZSY",428,0)
 ; ZEXCEPT: shell
"RTN","ZSY",429,0)
 n %cmd s %cmd="PATH=$PATH:/usr/sbin lsof -t "_$$DEFFILE
"RTN","ZSY",430,0)
 i $ZV["CYGWIN" s %cmd="ps -a | grep mumps | grep -v grep | awk '{print $1}'"
"RTN","ZSY",431,0)
 i $ZV["Darwin" s %cmd="pgrep -a mumps | xargs -n 1 -I{} lsof -p{} | grep "_$$DEFFILE_" | awk '{print $2}'"
"RTN","ZSY",432,0)
 n oldio s oldio=$IO
"RTN","ZSY",433,0)
 o "lsof":(shell="/bin/bash":command=%cmd)::"pipe"
"RTN","ZSY",434,0)
 u "lsof"
"RTN","ZSY",435,0)
 n i f i=1:1 q:$ZEOF  r procs(i):1  i procs(i)="" k procs(i)
"RTN","ZSY",436,0)
 u oldio c "lsof"
"RTN","ZSY",437,0)
 i $zclose s $ec=",U-lsof-or-other-not-found,"
"RTN","ZSY",438,0)
 n cnt s cnt=0
"RTN","ZSY",439,0)
 n i f i=0:0 s i=$o(procs(i)) q:'i  i $i(cnt)
"RTN","ZSY",440,0)
 quit:$Q cnt quit
"RTN","ZSY",441,0)
 ;
"RTN","ZSY",442,0)
INTRPT(%J) ; [Public] Send mupip interrupt (currently SIGUSR1)
"RTN","ZSY",443,0)
 N SIGUSR1
"RTN","ZSY",444,0)
 I $ZV["Linux" S SIGUSR1=10
"RTN","ZSY",445,0)
 I $ZV["Darwin" S SIGUSR1=30
"RTN","ZSY",446,0)
 I $ZV["CYGWIN" S SIGUSR1=30
"RTN","ZSY",447,0)
 N % S %=$ZSIGPROC(%J,SIGUSR1)
"RTN","ZSY",448,0)
 QUIT
"RTN","ZSY",449,0)
 ;
"RTN","ZSY",450,0)
INTRPTALL(procs) ; [Public] Send mupip interrupt to every single database process
"RTN","ZSY",451,0)
 N SIGUSR1
"RTN","ZSY",452,0)
 I $ZV["Linux" S SIGUSR1=10
"RTN","ZSY",453,0)
 I $ZV["Darwin" S SIGUSR1=30
"RTN","ZSY",454,0)
 I $ZV["CYGWIN" S SIGUSR1=30
"RTN","ZSY",455,0)
 ; Collect processes
"RTN","ZSY",456,0)
 D UNIXLSOF(.procs)
"RTN","ZSY",457,0)
 ; Signal all processes
"RTN","ZSY",458,0)
 N i,% s i=0 f  s i=$o(procs(i)) q:'i  S %=$ZSIGPROC(procs(i),SIGUSR1)
"RTN","ZSY",459,0)
 QUIT
"RTN","ZSY",460,0)
 ;
"RTN","ZSY",461,0)
HALTALL ; [Public] Gracefully halt all jobs accessing current database
"RTN","ZSY",462,0)
 ; Calls ^XUSCLEAN then HALT^ZU
"RTN","ZSY",463,0)
 ;Clear old data
"RTN","ZSY",464,0)
 S ^XUTL("XUSYS","COMMAND")="Status"
"RTN","ZSY",465,0)
 N I F I=0:0 S I=$O(^XUTL("XUSYS",I)) Q:'I  K ^XUTL("XUSYS",I,"JE"),^("INTERUPT")
"RTN","ZSY",466,0)
 ;
"RTN","ZSY",467,0)
 ; Get jobs accessing this database
"RTN","ZSY",468,0)
 n procs d UNIXLSOF(.procs)
"RTN","ZSY",469,0)
 ;
"RTN","ZSY",470,0)
 ; Tell them to stop
"RTN","ZSY",471,0)
 n i f i=0:0 s i=$o(procs(i)) q:'i  s ^XUTL("XUSYS",procs(i),"CMD")="HALT"
"RTN","ZSY",472,0)
 K ^XUTL("XUSYS",$J,"CMD")  ; but not us
"RTN","ZSY",473,0)
 ;
"RTN","ZSY",474,0)
 ; Sayonara
"RTN","ZSY",475,0)
 N J F J=0:0 S J=$O(procs(J)) Q:'J  D INTRPT(procs(J))
"RTN","ZSY",476,0)
 ;
"RTN","ZSY",477,0)
 ; Wait; Long hang for TCP jobs that can't receive interrupts for .2 seconds
"RTN","ZSY",478,0)
 H .25
"RTN","ZSY",479,0)
 ;
"RTN","ZSY",480,0)
 ; Check that they are all dead. If not, kill it "softly".
"RTN","ZSY",481,0)
 ; Need to do this for node and java processes that won't respond normally.
"RTN","ZSY",482,0)
 N J F J=0:0 S J=$O(^XUTL("XUSYS",J)) Q:'J  I $zgetjpi(J,"isprocalive"),J'=$J D KILL(J)
"RTN","ZSY",483,0)
 ;
"RTN","ZSY",484,0)
 quit
"RTN","ZSY",485,0)
 ;
"RTN","ZSY",486,0)
HALTONE(%J) ; [Public] Halt a single process
"RTN","ZSY",487,0)
 S ^XUTL("XUSYS",%J,"CMD")="HALT"
"RTN","ZSY",488,0)
 D INTRPT(%J)
"RTN","ZSY",489,0)
 H .25 ; Long hang for TCP jobs that can't receive interrupts
"RTN","ZSY",490,0)
 I $zgetjpi(%J,"isprocalive") D KILL(%J)
"RTN","ZSY",491,0)
 QUIT
"RTN","ZSY",492,0)
 ;
"RTN","ZSY",493,0)
KILL(%J) ; [Private] Kill %J
"RTN","ZSY",494,0)
 ; ZEXCEPT: shell
"RTN","ZSY",495,0)
 n %cmd s %cmd="kill "_%J
"RTN","ZSY",496,0)
 o "kill":(shell="/bin/sh":command=%cmd)::"pipe" u "kill" c "kill"
"RTN","ZSY",497,0)
 quit
"RTN","ZSY",498,0)
 ;
"RTN","ZSY",499,0)
ZJOB(PID) G JOBVIEWZ ; [Public, Interactive] Examine a specific job -- written by OSEHRA/SMH
"RTN","ZSY",500,0)
EXAMJOB(PID) G JOBVIEWZ ;
"RTN","ZSY",501,0)
VIEWJOB(PID) G JOBVIEWZ ;
"RTN","ZSY",502,0)
JOBVIEW(PID) G JOBVIEWZ ;
"RTN","ZSY",503,0)
JOBVIEWZ ;
"RTN","ZSY",504,0)
 ; ZEXCEPT: CTRAP,NOESCAPE,NOFILTER,PID
"RTN","ZSY",505,0)
 U $P:(CTRAP=$C(3):NOESCAPE:NOFILTER)
"RTN","ZSY",506,0)
 I $G(PID) D JOBVIEWZ2(PID) QUIT
"RTN","ZSY",507,0)
 D ^ZSY
"RTN","ZSY",508,0)
 N X,DONE
"RTN","ZSY",509,0)
 S DONE=0
"RTN","ZSY",510,0)
 ; Nasty read loop. I hate read loops
"RTN","ZSY",511,0)
 F  D  Q:DONE
"RTN","ZSY",512,0)
 . R !,"Enter a job number to examine (^ to quit): ",X:$G(DTIME,300)
"RTN","ZSY",513,0)
 . E  S DONE=1 QUIT
"RTN","ZSY",514,0)
 . I X="^" S DONE=1 QUIT
"RTN","ZSY",515,0)
 . I X="" D ^ZSY QUIT
"RTN","ZSY",516,0)
 . I X["?" D ^ZSY QUIT
"RTN","ZSY",517,0)
 . ;
"RTN","ZSY",518,0)
 . D JOBVIEWZ2(X)
"RTN","ZSY",519,0)
 . D ^ZSY
"RTN","ZSY",520,0)
 QUIT
"RTN","ZSY",521,0)
 ;
"RTN","ZSY",522,0)
JOBVIEWZ2(X) ; [Private] View Job Information
"RTN","ZSY",523,0)
 I X'?1.N W !,"Not a valid job number." Q
"RTN","ZSY",524,0)
 I '$zgetjpi(X,"isprocalive") W !,"This process does not exist" Q
"RTN","ZSY",525,0)
 ;
"RTN","ZSY",526,0)
 N EXAMREAD
"RTN","ZSY",527,0)
 N DONEONE S DONEONE=0
"RTN","ZSY",528,0)
 F  D  Q:DONEONE  ; This is an inner read loop to refresh a process.
"RTN","ZSY",529,0)
 . N % S %=$$EXAMINEJOBBYPID(X)
"RTN","ZSY",530,0)
 . I %'=0 W !,"The job didn't respond to examination for 305 ms. You may try again." S DONEONE=1 QUIT
"RTN","ZSY",531,0)
 . D PRINTEXAMDATA(X,$G(EXAMREAD))
"RTN","ZSY",532,0)
 . W "Enter to Refersh, V for variables, I for ISVs, K to kill",!
"RTN","ZSY",533,0)
 . W "L to load variables into your ST and quit, ^ to go back: ",!
"RTN","ZSY",534,0)
 . W "D to debug (broken), Z to zshow all data for debugging."
"RTN","ZSY",535,0)
 . R EXAMREAD:$G(DTIME,300)
"RTN","ZSY",536,0)
 . E  S DONEONE=1
"RTN","ZSY",537,0)
 . I EXAMREAD="^" S DONEONE=1
"RTN","ZSY",538,0)
 . I $TR(EXAMREAD,"k","K")="K" D HALTONE(X) S DONEONE=1
"RTN","ZSY",539,0)
 QUIT
"RTN","ZSY",540,0)
 ;
"RTN","ZSY",541,0)
EXAMINEJOBBYPID(%J) ; [$$, Public, Silent] Examine Job by PID; Non-zero output failure
"RTN","ZSY",542,0)
 Q:'$ZGETJPI(%J,"isprocalive") -1
"RTN","ZSY",543,0)
 K ^XUTL("XUSYS",%J,"CMD"),^("JE")
"RTN","ZSY",544,0)
 S ^XUTL("XUSYS",%J,"CMD")="EXAM"
"RTN","ZSY",545,0)
 D INTRPT(%J)
"RTN","ZSY",546,0)
 N I F I=1:1:5 H .001 Q:$G(^XUTL("XUSYS",%J,"JE","COMPLETE"))
"RTN","ZSY",547,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .2
"RTN","ZSY",548,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .2
"RTN","ZSY",549,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) Q -1
"RTN","ZSY",550,0)
 QUIT 0
"RTN","ZSY",551,0)
 ;
"RTN","ZSY",552,0)
PRINTEXAMDATA(%J,FLAG) ; [Private] Print the exam data
"RTN","ZSY",553,0)
 ; ^XUTL("XUSYS",8563,"JE","INTERRUPT")="GETTASK+3^%ZTMS1"
"RTN","ZSY",554,0)
 ; ^XUTL("XUSYS",8563,"JE","G",0)="GLD:*,REG:*,SET:25610,KIL:593,GET:12284,...
"RTN","ZSY",555,0)
 ; ^XUTL("XUSYS",8563,"JE","ZMODE")="OTHER"
"RTN","ZSY",556,0)
 N ZSY M ZSY=^XUTL("XUSYS",%J)
"RTN","ZSY",557,0)
 ;
"RTN","ZSY",558,0)
 N BOLD S BOLD=$C(27,91,49,109)
"RTN","ZSY",559,0)
 N RESET S RESET=$C(27,91,109)
"RTN","ZSY",560,0)
 N UNDER S UNDER=$C(27,91,52,109)
"RTN","ZSY",561,0)
 N DIM S DIM=$$AUTOMARG()
"RTN","ZSY",562,0)
 ;
"RTN","ZSY",563,0)
 ; Debug
"RTN","ZSY",564,0)
 I $TR(FLAG,"d","D")="D" D DEBUG(%J)
"RTN","ZSY",565,0)
 ;
"RTN","ZSY",566,0)
 ; Show all data
"RTN","ZSY",567,0)
 I $TR(FLAG,"z","Z")="Z" ZWRITE ZSY QUIT
"RTN","ZSY",568,0)
 ;
"RTN","ZSY",569,0)
 ; List Variables?
"RTN","ZSY",570,0)
 I $TR(FLAG,"v","V")="V" D  QUIT
"RTN","ZSY",571,0)
 . W !!,BOLD,"Variables: ",RESET,!
"RTN","ZSY",572,0)
 . N V F V=0:0 S V=$O(ZSY("JE","V",V)) Q:'V  W ZSY("JE","V",V),!
"RTN","ZSY",573,0)
 ;
"RTN","ZSY",574,0)
 ; Load Variables into my Symbol Table?
"RTN","ZSY",575,0)
 ; ZGOTO pops the stack and drops you to direct mode ($ZLEVEL is 2 to exit one above direct mode)
"RTN","ZSY",576,0)
 I $TR(FLAG,"l","L")="L" D  ZGOTO 2:LOADST
"RTN","ZSY",577,0)
 . K ^TMP("ZSY",$J)
"RTN","ZSY",578,0)
 . M ^TMP("ZSY",$J)=ZSY("JE","V")
"RTN","ZSY",579,0)
 ;
"RTN","ZSY",580,0)
 ; List ISVs?
"RTN","ZSY",581,0)
 I $TR(FLAG,"i","I")="I" D  QUIT
"RTN","ZSY",582,0)
 . W !!,BOLD,"ISVs: ",RESET,!
"RTN","ZSY",583,0)
 . N I F I=0:0 S I=$O(ZSY("JE","I",I)) Q:'I  W ZSY("JE","I",I),!
"RTN","ZSY",584,0)
 ;
"RTN","ZSY",585,0)
 ; Normal Display: Job Info, Stack, Locks, Devices
"RTN","ZSY",586,0)
 W #
"RTN","ZSY",587,0)
 W UNDER,"JOB INFORMATION FOR "_%J," (",$ZDATE(ZSY(0),"YYYY-MON-DD 24:60:SS"),")",RESET,!
"RTN","ZSY",588,0)
 W BOLD,"AT: ",RESET,ZSY("JE","INTERRUPT"),": ",$G(ZSY("JE","codeline")),!!
"RTN","ZSY",589,0)
 ;
"RTN","ZSY",590,0)
 N CNT S CNT=1
"RTN","ZSY",591,0)
 W BOLD,"Stack: ",RESET,!
"RTN","ZSY",592,0)
 ; Stack is funny -- print just to $ZINTERRUPT
"RTN","ZSY",593,0)
 N S F S=$O(ZSY("JE","R"," "),-1):-1:1 Q:ZSY("JE","R",S)["$ZINTERRUPT"  D
"RTN","ZSY",594,0)
 . N PLACE S PLACE=$P(ZSY("JE","R",S),":")
"RTN","ZSY",595,0)
 . I $E(PLACE)=" " QUIT  ; GTM adds an extra level sometimes for display -- messes me up
"RTN","ZSY",596,0)
 . W CNT,". "
"RTN","ZSY",597,0)
 . I PLACE'["GTM$DMOD" W PLACE,?40,$T(@PLACE)
"RTN","ZSY",598,0)
 . W !
"RTN","ZSY",599,0)
 . S CNT=CNT+1
"RTN","ZSY",600,0)
 W CNT,". ",ZSY("JE","INTERRUPT"),":",?40,$G(ZSY("JE","codeline")),!
"RTN","ZSY",601,0)
 ;
"RTN","ZSY",602,0)
 W !
"RTN","ZSY",603,0)
 W BOLD,"Locks: ",RESET,!
"RTN","ZSY",604,0)
 N L F L=0:0 S L=$O(ZSY("JE","L",L)) Q:'L  W ZSY("JE","L",L),!
"RTN","ZSY",605,0)
 ;
"RTN","ZSY",606,0)
 W !
"RTN","ZSY",607,0)
 W BOLD,"Devices: ",RESET,!
"RTN","ZSY",608,0)
 N D F D=0:0 S D=$O(ZSY("JE","D",D)) Q:'D  W ZSY("JE","D",D),!
"RTN","ZSY",609,0)
 ;
"RTN","ZSY",610,0)
 W !
"RTN","ZSY",611,0)
 W BOLD,"Breakpoints: ",RESET,!
"RTN","ZSY",612,0)
 N B F B=0:0 S B=$O(ZSY("JE","B",B)) Q:'B  W ZSY("JE","B",B),!
"RTN","ZSY",613,0)
 ;
"RTN","ZSY",614,0)
 W !
"RTN","ZSY",615,0)
 W BOLD,"Global Stats for default region: ",RESET,!
"RTN","ZSY",616,0)
 N G S G=""
"RTN","ZSY",617,0)
 N SLOTS S SLOTS=+DIM\15
"RTN","ZSY",618,0)
 N SLOT S SLOT=0
"RTN","ZSY",619,0)
 F  S G=$O(ZSY("JE","GSTAT",G)) Q:G=""  D
"RTN","ZSY",620,0)
 . I G="GLD" QUIT
"RTN","ZSY",621,0)
 . N V S V=ZSY("JE","GSTAT",G)
"RTN","ZSY",622,0)
 . I V>9999 S V=$J(V/1024,"",0)_"k"
"RTN","ZSY",623,0)
 . I V>9999,V["k" S V=$J(V/1024,"",0)_"m"
"RTN","ZSY",624,0)
 . W ?(SLOT*15),G,": ",V," "
"RTN","ZSY",625,0)
 . S SLOT=SLOT+1
"RTN","ZSY",626,0)
 . I SLOT+1>SLOTS S SLOT=0 W !
"RTN","ZSY",627,0)
 W !!
"RTN","ZSY",628,0)
 ;
"RTN","ZSY",629,0)
 W BOLD,"String Pool (size,currently used,freed): ",RESET,ZSY("JE","SPOOL"),!!
"RTN","ZSY",630,0)
 QUIT
"RTN","ZSY",631,0)
 ;
"RTN","ZSY",632,0)
LOADST ; [Private] Load the symbol table into the current process
"RTN","ZSY",633,0)
 KILL
"RTN","ZSY",634,0)
 N V F V=0:0 S V=$O(^TMP("ZSY",$J,V)) Q:'V  S @^(V)
"RTN","ZSY",635,0)
 K ^TMP("ZSY",$J)
"RTN","ZSY",636,0)
 QUIT
"RTN","ZSY",637,0)
 ;
"RTN","ZSY",638,0)
DEBUG(%J) ; [Private] Debugging logic
"RTN","ZSY",639,0)
 Q:'$ZGETJPI(%J,"isprocalive") -1
"RTN","ZSY",640,0)
 ;
"RTN","ZSY",641,0)
 N TCPIO S TCPIO="SCK$LOCAL"
"RTN","ZSY",642,0)
 O TCPIO:(LISTEN="/tmp/ydb-debug-socket:local":delim=$C(4):attach="server":newversion):15:"socket"
"RTN","ZSY",643,0)
 U TCPIO
"RTN","ZSY",644,0)
 ;
"RTN","ZSY",645,0)
 W /LISTEN(1)
"RTN","ZSY",646,0)
 ;
"RTN","ZSY",647,0)
 K ^XUTL("XUSYS",%J,"CMD"),^("JE")
"RTN","ZSY",648,0)
 S ^XUTL("XUSYS",%J,"CMD")="DEBUG"
"RTN","ZSY",649,0)
 D INTRPT(%J)
"RTN","ZSY",650,0)
 N I F I=1:1:5 H .001 Q:$G(^XUTL("XUSYS",%J,"JE","COMPLETE"))
"RTN","ZSY",651,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .2
"RTN","ZSY",652,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .1
"RTN","ZSY",653,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) Q -1
"RTN","ZSY",654,0)
 ;
"RTN","ZSY",655,0)
 F  W /WAIT(10) Q:$KEY]""
"RTN","ZSY",656,0)
 R X
"RTN","ZSY",657,0)
 ;
"RTN","ZSY",658,0)
 QUIT 0
"RTN","ZSY",659,0)
 ;
"RTN","ZSY",660,0)
DEFREG() ; Default Region Name; *10004*
"RTN","ZSY",661,0)
 Q $VIEW("REGION","^DD")
"RTN","ZSY",662,0)
 ;
"RTN","ZSY",663,0)
DEFFILE() ; Default Region File Name ; *10004*
"RTN","ZSY",664,0)
 Q $V("GVFILE",$$DEFREG)
"RTN","ZSY",665,0)
 ;
"RTN","ZSY",666,0)
AUTOMARG() ;RETURNS IOM^IOSL IF IT CAN and resets terminal to those dimensions; GT.M
"RTN","ZSY",667,0)
 ; ZEXCEPT: APC,TERM,NOECHO,WIDTH
"RTN","ZSY",668,0)
 I $PRINCIPAL'["/dev/" quit:$Q "" quit
"RTN","ZSY",669,0)
 U $PRINCIPAL:(WIDTH=0)
"RTN","ZSY",670,0)
 N %I,%T,ESC,DIM S %I=$I,%T=$T D
"RTN","ZSY",671,0)
 . ; resize terminal to match actual dimensions
"RTN","ZSY",672,0)
 . S ESC=$C(27)
"RTN","ZSY",673,0)
 . U $P:(TERM="R":NOECHO)
"RTN","ZSY",674,0)
 . W ESC,"7",ESC,"[r",ESC,"[999;999H",ESC,"[6n"
"RTN","ZSY",675,0)
 . R DIM:1 E  Q
"RTN","ZSY",676,0)
 . W ESC,"8"
"RTN","ZSY",677,0)
 . I DIM?.APC U $P:(TERM="":ECHO) Q
"RTN","ZSY",678,0)
 . I $L($G(DIM)) S DIM=+$P(DIM,";",2)_"^"_+$P(DIM,"[",2)
"RTN","ZSY",679,0)
 . U $P:(TERM="":ECHO:WIDTH=+$P(DIM,";",2):LENGTH=+$P(DIM,"[",2))
"RTN","ZSY",680,0)
 ; restore state
"RTN","ZSY",681,0)
 U %I I %T
"RTN","ZSY",682,0)
 ; Extra just for ^ZJOB - don't wrap
"RTN","ZSY",683,0)
 U $PRINCIPAL:(WIDTH=0)
"RTN","ZSY",684,0)
 Q:$Q $S($G(DIM):DIM,1:"") Q
"VER")
8.0^22.2
**END**
**END**
